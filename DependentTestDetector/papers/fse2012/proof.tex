\subsection{Detecting Dependent Tests}

From a practical perspective, techniques that affect the ordering of
test suites must respect dependences. Otherwise their results cannot
be interpreted correctly in the presence of dependences. Detecting
dependences in existing test suites is thus an interesting problem.
In the following, we first give a precise definition of the problem of
detecting dependent tests, and then prove that in general this problem
is NP-complete. In Section~\ref{sec:algorithm-tool} we outline an
algorithm that approximates solutions efficiently.

\begin{definition}[Dependent Test Detection Problem]
Given a set suite\/ $T = \suite{t_1, \dots, t_n}$ and an environment\/
$\env_0$, for a given test\/ $t_i \in T$, is there a test suite\/ $S
\subseteq T$ that manifests a test dependence involving\/ $t_i$? 
\end{definition}

%To prove that this problem is NP-complete,
We prove that this problem is NP-hard by reducing the NP-complete Exact Cover problem
to the Dependent Test Detection
problem~\cite{karp:NP:1972}. 
Then we provide a linear time algorithm to verify any answer to the
question.
%Then we sketch an exponential
%time algorithm that can solve the problem.
Together these two parts prove the the Dependent Test Detection Problem is NP-complete.

\begin{theorem}
The problem of finding a test suite that manifests a dependence is
NP-hard.
\end{theorem}

\begin{proof}
%We prove this claim by reducing Exact Cover to Dependent Test
%Detection.
In the Exact Cover problem,
we are given a set $X$ = \{$x_1, x_2, x_3, \dots, x_m$\} and a collection $S$ of subsets of $X$.
The goal is to identify a sub-collection $S^*$ of $S$ such that \textit{each}
element in $X$ is contained in \textit{exactly} one subset in $S^*$.  

Assume a set $V = \{v_1, v_2, v_3, \dots, v_m\}$ of variables,
and a set $S = \{S_1, S_2, \dots, S_n\}$ with $S_i \subseteq V$ for $ 1\leq i
\leq n$. 

We now construct a tested program $P$, and a test suite
$T = \suite{t_1, t_2, \dots t_n , t_{n+1}}$ as follows:

\begin{itemize}

\item $P$ consists of $m$ global variables 
$v_1, v_2,\dots, v_m$, each with initial value 1.

\item 
For $1 \le i \le n$, $t_i$ is constructed as follows:
for $1 \le j \le m$, if $x_j \in S_i$, then adding a
single assignment statement \CodeIn{$v_j$ = $v_j$ - 1} to $t_i$.

$t_{n+1}$ consists only of the oracle
\CodeIn{assert($v_1$ != 0 || $v_2$ != 0 \dots || $v_m$ !=0)}.

\end{itemize}

In the above construction, the tests $t_i$ for $1 \le i \le n$ 
will always pass. The only
test that may fail and thus exhibit different behavior is $t_{n+1}$, which 
\emph{only} fails when each variable $v_i$ appears exactly
once in a test case.

For the given test $t_{n+1}$, if we can
find a sequence \suite{t_{i_1}, t_{i_2},\dots, t_{i_j}}
that makes $t_{n+1}$ fail, the subsets $S^*$ corresponding
to each $t_{i_j}$ are an exact cover of $V$.
\end{proof}

In practice, the structure of the proof directly translates to the
structure of test suites. $t_{n+1}$ is the dependent test, $S$ is
defined by the tests that write variables used by $t_{n+1}$, and every
exact cover of $S$ represents an independent shortest test suite that
is a manifest dependency of $t_{n+1}$.

To complete the proof that Dependent Test Detection is NP-complete, we
provide an algorithm to verify solutions to the problem, that is
linear in the size of the test suite.
Given a test suite $T$ and a test suite $S \subseteq T$ that is said
to manifest a dependency on $t_i$, we first execute $T$, then $S$, and
compare the result for $t_i$ in both executions. 
If the results differ the solution is correct, if they do not differ,
the solution is rejected.
Since in the worst case we have to execute $2n$ tests, the complexity
of this algorithm is linear.


