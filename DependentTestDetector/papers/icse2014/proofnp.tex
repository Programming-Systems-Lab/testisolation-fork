

\begin{proof}
%We prove this claim by reducing Exact Cover to Dependent Test
%Detection.
In the Exact Cover problem,
we are given a set $X$ = \{$x_1, x_2, x_3, \dots, x_m$\} and a collection $S$ of subsets of $X$.
The goal is to identify a sub-collection $S^*$ of $S$ such that \textit{each}
element in $X$ is contained in \textit{exactly} one subset in $S^*$.  

Assume a set $V = \{v_1, v_2, v_3, \dots, v_m\}$ of variables,
and a set $S = \{S_1, S_2, \dots, S_n\}$ with $S_i \subseteq V$ for $ 1\leq i
\leq n$. 

We now construct a tested program $P$, and a test suite
$T = \suite{t_1, t_2, \dots t_n , t_{n+1}}$ as follows:

\begin{itemize}

\item $P$ consists of $m$ global variables 
$v_1, v_2,\dots, v_m$, each with initial value 1.

\item 
For $1 \le i \le n$, $t_i$ is constructed as follows:
for $1 \le j \le m$, if $v_j \in S_i$, then add a
single assignment statement \CodeIn{$v_j$ = $v_j$ - 1} to $t_i$.

$t_{n+1}$ consists only of the oracle
\CodeIn{assert($v_1$ != 0 || $v_2$ != 0 \dots || $v_m$ !=0)}.

\end{itemize}

In the above construction, the tests $t_i$ for $1 \le i \le n$ 
will always pass. The only
test that may fail and thus exhibit different behavior is $t_{n+1}$, which 
\emph{only} fails when each variable $v_i$ appears exactly
once in a test case.

For the given test $t_{n+1}$, if we can
find a sequence \suite{t_{i_1}, t_{i_2},\dots, t_{i_j}}
that makes $t_{n+1}$ fail, the subsets $S^*$ corresponding
to each $t_{i_j}$ are an exact cover of $V$.

In practice, the structure of the proof directly translates to the
structure of test suites. $t_{n+1}$ is the dependent test, $S$ is
defined by the tests that write variables used by $t_{n+1}$, and every
exact cover of $S$ represents an independent shortest test suite that
is a manifest dependency of $t_{n+1}$.
\end{proof}

To complete the proof that Dependent Test Detection is NP-complete, we
provide an algorithm to verify a solution to the problem, that is
linear in the size of the test suite.
Given a test suite $T$, a test $t \in T$ and a sequence
$S \subseteq T$ that manifests a dependency on $t$, we first execute $T$, then $S$, and
compare the result for $t$ in both executions. 
If the results differ the solution is correct; if they do not differ,
the solution is rejected.
Since in the worst case we have to execute $2n$ tests, the complexity
of this algorithm is linear. 
