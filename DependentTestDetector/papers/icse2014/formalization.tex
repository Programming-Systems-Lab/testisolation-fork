
\section{Formalizing Test Dependence}
\label{sec:formalism}


The result of a test depends not only on
its input data but also on its \emph{execution conditions}.
To characterize the relevant execution conditions, 
our formalism represents
(a)~the order in which test cases are executed and (b)~the environment in which a test suite is executed.  


\subsection{Definitions}
\label{sec:definitions}

We express test dependences through the results of executing
\emph{ordered} sequences of tests in a given \emph{environment}.


\begin{definition}[Test]

A test is a sequence of executable program statements and an oracle
--- a Boolean predicate that
decides whether the test passes or fails.
\end{definition}

For simplicity, our definition does not consider non-deter\-min\-istic
tests, non-terminating tests, and tests aborting the JVM\@.


\begin{definition}[Test Suite]
A test suite\/ $T$ is an $n$-tuple (i.e., ordered sequence) of tests
\suite{t_1, t_2, \dots, t_n}.

%When it is clear which test suite we are talking about, or the details
%of the suite are not important, we use $T$ to denote the entire test
%suite $(t_1, \dots, t_n)$.
\end{definition}


\begin{definition}[Environment]
An \emph{environment} \env for the execution of a test
consists of all values of global variables, files,
operating
system services, etc.\ that
can be accessed by the test and program code exercised by the test
case.
\end{definition}

We use $\env_0$ to represent the initial environment, such
as a fresh JVM initialized by frameworks like JUnit
before executing any test.


\begin{definition}[Test Execution]
Let\/ \alltests\ be the set of all possible
tests and\/ \environs\ the set of all possible
environments.
The function\/ $\execfunc: \alltests \times \environs \rightarrow
\environs$ represents test
execution. $\execfunc$ maps the execution of a test\/ $ t \in
\alltests$ 
and an environment\/ $\env \in \environs$ to a new (potentially updated)
environment\/ $\env' \in \environs$.

Given a test suite\/ $T = \suite{t_1, t_2, \dots, t_n}$,
we use the shorthand\/
$\exec{T}{\env}$ for $\exec{t_n}{\exec{t_{n-1}}{{\dots \exec{t_1}
{\env} \dots }}}$, to represent its execution.
\end{definition}

Tests call into a program, but our definitions leave the program implicit,
since it is always clear from context.

\begin{definition}[Test Result]
The result of a test $t$ executed in an environment\/ $\env$,
denoted\/ \result{t}{\env}, is defined by the test's oracle
and is either \pass or \fail.

The result of a test suite\/ $T$ = \suite{t_1,\dots,t_n}, executed in an
environment\/ \env, denoted\/ \result{\suite{t_1,\dots,t_n}}{\env}, is a
sequence of results\/ \suite{o_1,\dots,o_n} with $o_i \in \{\pass,\fail\}$.
We use $\result{T}{\env}[t]$ to denote the result of a test $t \in T$.

%For test outcomes of sequences where all individual outcomes are
%either \pass or \fail, we use the notation $(\pass^*)$ and $(\fail^*)$,
%respectively.

For example, $\result{\suite{t_1, t_2}}{\env_1} = \suite{\fail, \pass}$ represents that if
$t_1$ then $t_2$ are run, starting with the environment\/ $\env_1$, then\/
$t_1$ fails and\/ $t_2$ passes.
\end{definition}

A manifest order-dependent test (for short, dependent test)
is one that can be exposed by 
reordering existing test cases.
A dependent test $t$ manifests only
if there are two test suites $S_1$ and $S_2$ which
are two permutations of the original test suite $T$,
in which $t$ exhibits a different result
in the execution $\exec{S_1}{\env_0}$
than in the execution $\exec{S_2}{\env_0}$.
%produces an
%environment that will make $t$ exhibit a
%different result than in the environment produced by $\exec{S_2}{\env_0}$.

\begin{definition}[Manifest Order-Dependent Test] \label{def:manifest}
Given a test suite\/ $T$, a test $t \in T$ is a
manifest order-de\-pen\-dent test in $T$ if $\exists$ two test suites
$S_1, S_2 \in \mbox{permutations}(T)$:
$\result{S_1}{\env_0}[t] \neq
\result{S_2}{\env_0}[t]$.
%
%${S_1 \subseteq T - t}$
%and ${S_2 \subseteq T - t}$: \result{t}{f(S_1, \env_0)} $\neq$
%\result{t}{f(S_2, \env_0)}.
%\footnote{$S \subseteq T - t$ represents that $S$ does not
%contain repetitive tests, and for each
%test $t' \in S$ such that $t' \in T$ and $t' \neq t$.}
\end{definition}

It would be possible to consider a test dependent if reordering could
affect any internal computation or heap value (non-manifest dependence);
but these internal details, such as order of elements in a hash table,
might never affect any test result: they could be false dependences.
Another alternative would be to ask
whether it is possible to write a new dependent test for an existing
test suite; but the answer to this question is trivially ``yes''.
This paper focuses on manifest dependence and works with real, existing
test suites to determine the practical impact and prevalence of dependent
tests.


\subsection{The Dependent Test Detection Problem}

We prove that the problem of detecting dependent tests
 is NP-complete.


\begin{definition}[Dependent Test Detection Problem]
Given a set suite\/ $T = \suite{t_1, \dots, t_n}$ and an initial environment\/
$\env_0$, is $t \in T$ a dependent test for $T$?
%there a test suite\/ $S
%\subseteq T$ that manifests a test dependence involving\/ $t_i$? 
\end{definition}

We prove that this problem is NP-hard by reducing the NP-complete Exact Cover problem
to the Dependent Test Detection
problem~\cite{karp:NP:1972}. 
Then we provide a linear-time algorithm to verify any answer to the
question.
%Then we sketch an exponential
%time algorithm that can solve the problem.
Together these two parts prove that the Dependent Test Detection Problem is NP-complete.

\begin{theorem}
The problem of determining whether a test is a dependent test for
a test suite is NP-complete.
\end{theorem}

\begin{proof}
Due to space limits, we omit the proof. Interested
readers can refer to~\cite{testdependence} for details.
\end{proof}

%\input{proofnp}

\subsection{Discussion}
\label{sec:formaldiscussion}

For the sake of simplicity, our formalism only
considers deterministic tests,
and excludes tests whose results might be affected by
non-determinism such as thread scheduling
and timing issues.
Our formalism excludes self-dependence, 
when executing the same test twice
may lead to different results. Our empirical study
indicates that self-dependent tests
are rare in practice. In addition, typical
downstream testing techniques such as test selection and
prioritization do not usually execute a test twice within the same JVM\@.


% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

%  LocalWords:  dependences tuple
