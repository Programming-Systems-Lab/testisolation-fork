
\section{Formalizing Test Dependence}
\label{sec:formalism}


The result of a test not only depends on
its input data but also its \emph{execution conditions}.
To characterize the relevant execution conditions, 
our formalism represents the notions of
(a) the order in which test cases are executed and (b) the environment in which a test suite is executed.  


\subsection{Definitions}
\label{sec:definitions}

We express test dependences through the results of executing
\emph{ordered} sequences of tests in a given \emph{environment}.


\begin{definition}[Environment]
An \emph{environment} \env for the execution of a test
consists of all values of global variables, files,
operating
system services, etc. that
can be accessed by the test and program code exercised by the test
case.
\end{definition}

We use $\env_0$ to represent the initial environment, such
as a fresh JVM initialized by frameworks like JUnit
before executing any test.


\begin{definition}[Test]

A test is a sequence of executable program statements, and an oracle
--- a Boolean predicate that
decides whether the test passes or fails.
\end{definition}

For simplicity, our definition does not consider non-deterministic
tests, non-terminating tests, and tests aborting the JVM.


\begin{definition}[Test Suite]
A test suite\/ $T$ is an $n$-tuple (i.e., ordered sequence) of tests
\suite{t_1, t_2, \dots, t_n}.

%When it is clear which test suite we are talking about, or the details
%of the suite are not important, we use $T$ to denote the entire test
%suite $(t_1, \dots, t_n)$.
\end{definition}


\begin{definition}[Test Execution]
Let\/ \alltests\ be the set of all possible
tests and\/ \environs\ the set of all possible
environments.
The function\/ $\execfunc: \alltests \times \environs \rightarrow
\environs$ is called test
execution. $f$ maps the execution of a test\/ $ t \in
\alltests$ 
in an environment\/ $\env \in \environs$ to a new (potentially updated)
environment\/ $\env' \in \environs$.

Given a test suite\/ $T = \suite{t_1, t_2, \dots, t_n}$,
we use the shorthand\/
$\exec{T}{\env}$ for $\exec{t_n}{\exec{t_{n-1}}{{\dots \exec{t_1}
{\env} \dots }}}$, to represent its execution.
\end{definition}

\begin{definition}[Test Result]
The result of a test $t$ executed in an environment\/ $\env$,
denoted\/ \result{t}{\env}, is defined by the test's oracle
and is either \pass or \fail.

The result of a test suite\/ $T$ = \suite{t_1,\dots,t_n}, executed in an
environment\/ \env, denoted\/ \result{\suite{t_1,\dots,t_n}}{\env} is a
sequence of results\/ \suite{o_1,\dots,o_n} with $o_i \in \{\pass,\fail\}$.
We use \result{T}{\env}[$t$] to denote the result of a test $t \in T$.

%For test outcomes of sequences where all individual outcomes are
%either \pass or \fail, we use the notation $(\pass^*)$ and $(\fail^*)$,
%respectively.

For example, $\result{\suite{t_1, t_2}}{\env_1} = \suite{\fail, \pass}$ represents that if
$t_1$ then $t_2$ are run, starting with the environment\/ $\env_1$, then\/
$t_1$ fails and\/ $t_2$ passes.
\end{definition}

A manifest dependent test is one that can be exposed by 
reordering existing test cases.
A dependent test $t$ manifests only
if there are two test suites $S_1$ and $S_2$ which
are two permutations of the original test suite $T$,
in which $t$ exhibits a different result
in the execution $\exec{S_1}{\env_0}$
than in the execution $\exec{S_2}{\env_0}$.
%produces an
%environment that will make $t$ exhibit a
%different result than in the environment produced by $\exec{S_2}{\env_0}$.

\begin{definition}[Manifest Dependent Test] \label{def:manifest}
Given a test suite\/ $T$, a test $t \in T$ is a
manifest dependent test if $\exists$ two test suites
$S_1, S_2 \in$ permutations($T$):
\result{t}{\exec{S_1}{\env_0}}[$t$] $\neq$
\result{t}{\exec{S_2}{\env_0}}[$t$].
%
%${S_1 \subseteq T - t}$
%and ${S_2 \subseteq T - t}$: \result{t}{f(S_1, \env_0)} $\neq$
%\result{t}{f(S_2, \env_0)}.
%\footnote{$S \subseteq T - t$ represents that $S$ does not
%contain repetitive tests, and for each
%test $t' \in S$ such that $t' \in T$ and $t' \neq t$.}
\end{definition}




\subsection{The Dependent Test Detection Problem}

We prove that the problem of detecting manifest dependent tests (for
short, dependent tests) is NP-complete.


\begin{definition}[Dependent Test Detection Problem]
Given a set suite\/ $T = \suite{t_1, \dots, t_n}$ and an initial environment\/
$\env_0$, for a given test\/ $t \in T$, is $t$ a manifest dependent test?
%there a test suite\/ $S
%\subseteq T$ that manifests a test dependence involving\/ $t_i$? 
\end{definition}

We prove that this problem is NP-hard by reducing the NP-complete Exact Cover problem
to the Dependent Test Detection
problem~\cite{karp:NP:1972}. 
Then we provide a linear time algorithm to verify any answer to the
question.
%Then we sketch an exponential
%time algorithm that can solve the problem.
Together these two parts prove the the Dependent Test Detection Problem is NP-complete.

\begin{theorem}
The problem of determining a dependent test in
a test suite is NP-hard.
\end{theorem}

\begin{proof}
%We prove this claim by reducing Exact Cover to Dependent Test
%Detection.
In the Exact Cover problem,
we are given a set $X$ = \{$x_1, x_2, x_3, \dots, x_m$\} and a collection $S$ of subsets of $X$.
The goal is to identify a sub-collection $S^*$ of $S$ such that \textit{each}
element in $X$ is contained in \textit{exactly} one subset in $S^*$.  

Assume a set $V = \{v_1, v_2, v_3, \dots, v_m\}$ of variables,
and a set $S = \{S_1, S_2, \dots, S_n\}$ with $S_i \subseteq V$ for $ 1\leq i
\leq n$. 

We now construct a tested program $P$, and a test suite
$T = \suite{t_1, t_2, \dots t_n , t_{n+1}}$ as follows:

\begin{itemize}

\item $P$ consists of $m$ global variables 
$v_1, v_2,\dots, v_m$, each with initial value 1.

\item 
For $1 \le i \le n$, $t_i$ is constructed as follows:
for $1 \le j \le m$, if $x_j \in S_i$, then add a
single assignment statement \CodeIn{$v_j$ = $v_j$ - 1} to $t_i$.

$t_{n+1}$ consists only of the oracle
\CodeIn{assert($v_1$ != 0 || $v_2$ != 0 \dots || $v_m$ !=0)}.

\end{itemize}

In the above construction, the tests $t_i$ for $1 \le i \le n$ 
will always pass. The only
test that may fail and thus exhibit different behavior is $t_{n+1}$, which 
\emph{only} fails when each variable $v_i$ appears exactly
once in a test case.

For the given test $t_{n+1}$, if we can
find a sequence \suite{t_{i_1}, t_{i_2},\dots, t_{i_j}}
that makes $t_{n+1}$ fail, the subsets $S^*$ corresponding
to each $t_{i_j}$ are an exact cover of $V$.

In practice, the structure of the proof directly translates to the
structure of test suites. $t_{n+1}$ is the dependent test, $S$ is
defined by the tests that write variables used by $t_{n+1}$, and every
exact cover of $S$ represents an independent shortest test suite that
is a manifest dependency of $t_{n+1}$.
\end{proof}

To complete the proof that Dependent Test Detection is NP-complete, we
provide an algorithm to verify a solution to the problem, that is
linear in the size of the test suite.
Given a test suite $T$, a test $t \in T$ and a sequence
$S \subseteq T$ that manifests a dependency on $t$, we first execute $T$, then $S$, and
compare the result for $t$ in both executions. 
If the results differ the solution is correct, if they do not differ,
the solution is rejected.
Since in the worst case we have to execute $2n$ tests, the complexity
of this algorithm is linear. 



\subsection{Discussion}
\label{sec:formaldiscussion}

For the sake of simplicity, our formalism only
considers deterministic tests,
and excludes tests whose results might be affected by
non-determinism such as thread scheduling.
Our formalism excludes self-dependence, 
when executing the same test twice
may lead to different results. Our empirical study
indicates that self-dependent tests
are rare in practice. In addition, typical
downstream testing techniques such as test selection and
prioritization do not usually execute a test twice within the same JVM.


% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

%  LocalWords:  dependences tuple
