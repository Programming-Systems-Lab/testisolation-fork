
%\section{What's the essence of what causes the dependences?}
%\section{Theory}
\section{Understanding Dependent Tests: Formalization}
\label{sec:formalism}

\todo{need a transition sentence here.}
A standard textbook states that ``[a] test case includes not only input data but
also any relevant \emph{execution conditions}
\dots''~\cite[p.~152, emphasis added]{pezze-young:2007}.   
To characterize the relevant execution conditions precisely, 
our formalism needs to represent the notions of
(a) the order in which test cases are executed and (b) the environment in which a test suite is executed.  


\subsection{Definitions}
\label{sec:definitions}

We express test dependences through the results of executing
\emph{ordered} sequences of tests in a given \emph{environment}.


\begin{definition}[Environment]
An \emph{environment} \env for the execution of a test
consists of all values of global variables, files,
operating
system services, etc. that
can be accessed by the test and program code exercised by the test
case.
%
%The set of all possible environments is denoted $\environs$.
\end{definition}

We use $\env_0$ to represent the initial environment, a fresh
JVM provided by frameworks such as JUnit.

\todo{check E0 above}

%the natural environment  provided by frameworks such as JUnit,
%and the only modifications of this environment happen through the

\begin{definition}[Test]
%\todo{DN}{I'm not sure what ``fixed, well-defined inputs means'' and I'm not sure we need it.
%Why not just ``a sequence of program statements''?}
%
%\todo{JW}{Abstractly, all programs take inputs and compute something
%based on them (unless they are a constant function or
%non-deterministic). A test case is not complete without well-defined
%inputs, simply because you can't run the program. The should be
%well-defined and fixed, so that you can repeatedly run your test,
%always get the same result, and be sure what that result should be
%according to your spec. While I agree that this is not well
%formulated, I think if we ask serious testing people to read this and
%we ignore the whole input thing (a lot of test generation only deals
%with generating inputs), we might be in trouble.}

A test is a sequence of program statements, executed with fixed,
well-defined inputs, and an oracle that
decides whether a test passes or fails.
\end{definition}

%\todo{DN}{Should we footnote this next oracle discussion?  And shorten it, since some of the
%soundness/completeness issues are with respect to specifications, which we don't mention/address.
%Should we?}

%\todo{JW}{I realized while I wrote this that eventually we will have
%to include oracles. That's why I at least wanted to mention something
%here. But I don't think it will be possible (and sensible) to do fully
%integrate that now. The paragraph below is a summary of why we need to
%talk about this.}

%Generally, oracles are an important aspect of testing. Here, however,
%only two facts are relevant. First, Staats et al.\ discuss that oracles are
%often neither sound nor complete as we
%define them below often imply unsound oracles. Second, 
%In particular, that means that an oracle can decide that a
%test passes, while the program is incorrect. Test dependences
Simplifying from Staats
et al.~\cite{staatsetal:ICSE:2011}, and without loss of generality,
we consider an oracle to be a boolean predicate over tests and environments.

%While oracles in practice, and specifications in theory, play an
%important role in testing, we do not incorporate them in our
%formalism, because explicit specifications often do not exist, and for
%our purposes the oracle judgement, rather than its full definition, is sufficient.

\begin{definition}[Test Suite]
A test suite\/ $T$ is an $n$-tuple (i.e., ordered sequence) of tests
\suite{t_1, t_2, \dots, t_n}.

%When it is clear which test suite we are talking about, or the details
%of the suite are not important, we use $T$ to denote the entire test
%suite $(t_1, \dots, t_n)$.
\end{definition}

\begin{definition}[Test Execution]
Let\/ $T$ be a test suite and\/ \environs\ the set of all possible
environments.
The function\/ $\varepsilon: T \times \environs \rightarrow
\environs$ is called test
execution. $\varepsilon$ maps the execution of a test\/ $ t \in T$ 
in an environment\/ $\env \in \environs$ to the new (potentially updated)
environment\/ $\env'$.

For the execution of test suites\/ $T = \suite{t_1, t_2, \dots, t_n}$
we use the shorthand\/
$\exec{T}{\env}$ for $\exec{t_n}{\exec{t_{n-1}}{\dots \exec{t_1}
{\env} \dots }}$.
\end{definition}

\begin{definition}[Test Result]
The result of a test $t$ executed in an environment\/ $\env$,
denoted\/ \result{t}{\env} (and sometimes referred to 
as an oracle judgment), is defined by the test's oracle
and is either \pass or \fail.

The result of a test suite\/ \suite{t_1,\dots,t_n}, executed in an
environment\/ \env, denoted\/ \result{\suite{t_1,\dots,t_n}}{\env} is a
sequence of results\/ \suite{o_1,\dots,o_n} with $o_i \in \{\pass,\fail\}$.

%For test outcomes of sequences where all individual outcomes are
%either \pass or \fail, we use the notation $(\pass^*)$ and $(\fail^*)$,
%respectively.

For example, $\result{\suite{t_1, t_2}}{\env_1} = \suite{\fail, \pass}$ represents that 
given the environment\/ $\env_1$, $t_1$ fails and\/ $t_2$ passes.
\end{definition}


%\todo{DN}{Do we need the following paragraph?  I think the dot notation is unnecessary,
%since it's always a test suite, even if not the ``original'' one that we put in this
%place.  Also, I would -- again -- like to remove the references to Junit, VMs, etc. here.}
%
%The notation \result{\cdot}{\env} implies that only the explicitly specified
%tests are run in a given VM, execution, and environment \env. 
%In specific frameworks, such as JUnit, a single test would 
%include any automatically executed setup and the actual test method.

%The terminology for \pass and \fail is general:
%a test passes when its outcome is as expected and
%no assertion is violated; a test fails under all other circumstances.\footnote{In
%the JUnit framework, for example, this means that the outcomes \emph{failure} and \emph{error}
%would both be treated as \fail in the formalism.}

%The execution of tests can change the environment if one of the
%variables in it is modified. We write \exec{T}{\env} for the environment
%that derives from executing test suite $T$ in the original environment
%$\env$. $\exec{T}{\env} \neq \env$ is a necessary but not
%sufficient condition for test order dependencies.

%\begin{definition}[Potential Test Dependence] \label{def:dependency}
%Given a test suite\/ $T$,
%a test\/ $t_l \in T$ is \emph{potentially dependent} on test\/ $t_k
%\in T$, if and only if\/
%$\exists \env : \result{T}{\env} = \suite{o_1,\dots, o_n} \wedge
%\result{\suite{t_k,t_l}}{\env} = \suite{o_k, o_l} \wedge
%\result{t_l}{\env} = \neg o_l$.
%We write\/ $t_k \prec t_l$ when\/ $t_l$ is potentially dependent on\/ $t_k$.
%\end{definition}

\begin{definition}[Potential Test Dependence] \label{def:manifest}
Given a test suite\/ $T$, two tests\/ $t_i, t_j \in T$
are \textit{potentially} dependent, if\/ $\exists {S \subseteq T}: t_i, t_j \in S \wedge
$\exec{S, t_i, t_j}{\env}$ \neq $\exec{S, t_j, t_i}{\env_0}$.
$We write\/ $t_i \prec t_j$ for potential dependence.\footnote{$S \subseteq T$ means that $S$ is a subsequence of
$T$.}
\end{definition}

\todo{check the above potential test dependence definition.}
Two tests are potentially dependent when they are accessing the
same memory location or external file systems during execution.
Thus, executing them in different orders can lead to different envrionments. However,
such environment differences may not be checked and then manifest
through the test code.

%It is \emph{potential} as it only requires the existence of such an
%environment, but does not
%guarantee that the test suite will ever be executed in the context
%of such an environment.

%One direct implication of this definition is that $t_k \prec t_l
%\rightarrow \exec{t_k}{\env} \neq \env$, that is $t_k$ must modify the
%environment. Additionally, $t_l$ must read values from the
%environment.
%\todo{DN}{I'm not certain if the rightarrow is implication.  I'm not sure
%why this implication is crucial.}

%\begin{theorem}\label{theorem:pairs}
%
%$( t_1, \dots, t_k ) \prec t_n \Rightarrow \exists_{t \in (t_1, \dots,
%t_k)} : t \prec t_n $
%
%\end{theorem}
%
%\begin{proof}
%Proof by contradiction.
%
%Let $s = (t_1, \dots, t_k)$ be a test sequence of length greater than
%one, and let $s$ be the shortest sequence such that $ s \prec t_n$.
%I.e. there is no real prefix or suffix of $s$ that $t_n$ depends on.
%
%That means that there is an environment $\env_x$, such that $R(s,t_n :
%\env_x) \neq R(s:\env_x) \circ R(t_n:\env_x)$ 
%and for all environments $\env$
%$R(t_2, \dots, t_k, t_n:\env) = R(t_2,\dots, t_k:\env) \circ
%R(t_n:\env)$. In particular, this holds also for the environment
%$ \env_1 = \gamma(t_1, \env_x)$. 
%
%$R(s,t_n :\env_x) \neq R(s:\env_x) \circ R(t_n:\env_x)$
%and $\env$
%$R(t_2, \dots, t_k, t_n:\env_1) = R(t_2,\dots, t_k:\env_1) \circ
%R(t_n:\env_1)$ implies that $R(t_1,t_n:\env_x) \neq R(t_1:\env_x) \circ
%R(t_n:\env_x)$, which contradicts the
%hypothesis that there is no prefix of $s$ that $t_n$ depends on.
%\end{proof}
%
%Theorem~\ref{theorem:pairs} is useful for theoretical work because it
%reduces the complexity of the structures we have to study to pairs of
%tests. From a practical point of view, however, things are not quite
%as easy, because the proof only states the existence of environments
%that will expose the dependency, but does not constructively describe
%how to find these environments. Further, the whole theoretical
%framework by its nature cannot relate this to the way environments are
%constructed by actual testing frameworks such as JUnit. 
%
%With the above proof it is easy to see that the following corollary
%also holds:
%
%\begin{corollary}
%$t_k \prec (t_m, t_n) \Rightarrow t_k \prec t_m \vee t_k \prec t_n$
%\end{corollary}
%
%\begin{proof}
%Case 1: If the outcome of $t_m$ differs, it directly implies $t_k \prec t_m$.
%
%Case 2: The outcome of $t_m$ is the same, but $t_n$ differs.
%$ t_k \prec (t_m,t_n) \Rightarrow (t_k, t_m) \prec t_n \Rightarrow t_k
%\prec t_n$ 
%
%\end{proof}
%
%The above definitions and the properties of order dependencies that
%follow from these definitions allow some reasoning about order
%dependencies already. From a practical point of view, however, it
%would be desirable that the relation implied by the order dependence
%definition were a partial order. However, I do not think that that is
%true. The following theorem frames this:
%
%\begin{theorem}[Cyclic dependencies]
%There exist test suites $S$ such that for some $t_m, t_n \in S: t_m
%\prec t_n \wedge t_n \prec t_m$
%\end{theorem}
%
%This is an artifact of the fact that we allow reordering and our
%definition of order dependency hinges on the \emph{outcome} of
%executions.
%
%Intuitively, test dependencies $t \prec r$ between two tests $t$ and $r$ arise
%when $r$ expects some variable $v$ of the environment to have a specific
%value, but in the environment $\gamma(t,\env)$ $v$ has a different
%value (for some arbitrary $\env$).
%This situation can arise either by $r$ assigning an unexpected value
%to $v$, or $r$ failing to assign the expected value.
%
%\subsubsection{Manifest Dependencies}
%
%
%For practical reasons, the pure existence of an environment that
%exposes dependencies is not sufficient. Most of the time we are more
%concerned whether or not dependencies will become apparent in the
%environment we are actually dealing with.
%
%\todo{JW}{ We are aiming at defining enough theory for useful
%algorithms. In practice we derive our environments from some sort of
%default environment provided by the test framework. While we don't
%know the exact shape of that environment, assuming deterministic
%programs and tests, all other environments created through test
%execution derive from this initial environment. This must have some
%sort of impact on the complexity of our problem.}

%\begin{definition}[Subsequence]
%Given an ordered se\-quence $T = \suite{t_1, \dots t_n}$, an ordered
%sequence $S = \suite{t_i,\dots,t_k}$ is a subsequence of $T$, if and
%only if the length of $S$ is less than or equal to the length of $T$,
%the elements of $S$ are also elements of $T$ and 
%preserve the order of the elements in $T$.
%Analogously to sets, we write $S \subseteq T$ if $S$ is a subsequence of
%$T$.
%\end{definition}

We refine this definition of dependence to require a concrete environment guaranteed
to \emph{manifest} a dependence:
\begin{definition}[Manifest Test Dependence] \label{def:manifest}
Given a test suite\/ $T$, two dependent tests\/ $t_i, t_j \in T$,
the dependence\/ $t_i \prec t_j$ \emph{manifests} in a given
environment\/
$\env$ if\/ $\exists {S \subseteq T}: t_i, t_j \in S \wedge
\result{T}{\env}
= \suite{o_1, \dots, o_n} \wedge \result{S}{\env} =
\suite{\dots,o_i,o_j} \wedge \result{t_j}{\env} = \neg o_j$. We
write\/ $t_i \manifest{\env} t_j$ for manifest dependence.
%\footnote{$S \subseteq T$ means that $S$ is a subsequence of $T$.}
\end{definition}

%Note that the dependent tests $t_i$\/ and $t_j$ do not have to be
%adjacent in the original test suite, but that they must be adjacent in
%the shortest test suite that manifests the dependence.

%The intuition behind manifest dependences is that in practice we
%do not construct arbitrary environments to execute tests in. Rather,
%we use the natural environment $\env_0$ provided by frameworks such as JUnit,


This definition of manifest test dependence is \emph{dynamic} because
dependence arises only if the actual test results differ.
The manifest test dependence focuses on environment modified
by the tests and the tested code. Such dependences manifest only
if there is a sequence of tests $S^*$ whose execution
$\exec{S^*}{\env_0}$  produces the
environment $\env'$ that will make a test exhibit results.

%The algorithm we propose in Section~\ref{sec:algorithm-tool} detects
%dependences by running tests and checking for different test results,
%hence it can only detect manifest dependences.
%
%Note that this definition defines manifest dependencies with regard to
%a given test suite $T$ and a given environment $\env$. Thus it
%reduces the space of possible dependencies considerably. In practice,
%the given environment $\env$ is what the text execution framework
%provides \emph{before} it executes the first test.
%To improve algorithms that are affected by test dependences, we are
%interested in the shortest test suite $S^* \subseteq T$ that manifests a
%dependence, because these define the partial order of test execution
%that such techniques must respect.

%\begin{theorem}[Dependency bound]
%Let $U$ by a true sub-sequence of length $k$ of 
%a given test suite $T$, and let $U$
%be the shortest such sub-sequence that manifests a dependency with
%test t, i.e. $ U \manifest{\env} t$.
%Then there are at least $k$ variables responsible for manifesting the
%dependency.
%\end{theorem}
%
%\todo{JW}{ I'm not sure if this theorem actually holds. I'm working on
%it, but if anyone has ideas and insights, they are certainly welcome.}
%\todo{KM}{ I don't think this is true, consider the following: \\ 
%Initial environment: a = 0 \\ 
%Test1: {assert a == 3} \\
%Test2: {a = a + 1, assert true} \\
%Test3: {a = a + 2, assert true} \\
%In this setup Test1 depends on any order of Test2 and Test3. This is the minimum
%dependence (i.e., running only Test2 or Test3 won't suffice). However, the
%dependency only requires one variable, `a'. }
%
%\begin{proof}
%Proof by induction.
%Let $k=1$. Trivial. By definition there must be at least one variable
%that creates and manifests the dependency.
%
%Let $k=n+1$. Assume there are less than $k$ variables involved. 
%\end{proof}

%In later sections we often talk about executing tests in isolation, or
%executing all tests in a test suite in isolation. This is an important
%approximation to detecting test dependences.

%\todo{I think we need to add an example of potential test dependence
%and manifest test dependence in this section.}

%\begin{definition}[Test Isolation]
%The result of executing a test\/ $t$ in isolation, given an
%environment\/
%$\env_0$ is the result\/ \result{t}{\env_0} of executing that test in
%the given environment.  

%The result of executing all tests in a test suite\/ \suite{t_1, \dots,
%t_m} in isolation is the
%sequence of results\/ \suite{\result{t_1}{\env_0}, \dots,
%\result{t_n}{\env_0}}.
%\end{definition}


\subsection{The Dependent Test Detection Problem}

From a practical perspective, techniques that affect the ordering of
test suites must respect dependences. Otherwise their results cannot
be interpreted correctly in the presence of dependences. Detecting
dependences in existing test suites is thus an interesting problem.
In the following, we first give a precise definition of the problem of
detecting dependent tests, and then prove that in general this problem
is NP-complete. 

%In Section~\ref{sec:algorithm-tool} we outline an
%algorithm that approximates solutions efficiently.

\begin{definition}[Dependent Test Detection Problem]
Given a set suite\/ $T = \suite{t_1, \dots, t_n}$ and an environment\/
$\env_0$, for a given test\/ $t_i \in T$, is there a test suite\/ $S
\subseteq T$ that manifests a test dependence involving\/ $t_i$? 
\end{definition}

%To prove that this problem is NP-complete,
We prove that this problem is NP-hard by reducing the NP-complete Exact Cover problem
to the Dependent Test Detection
problem~\cite{karp:NP:1972}. 
Then we provide a linear time algorithm to verify any answer to the
question.
%Then we sketch an exponential
%time algorithm that can solve the problem.
Together these two parts prove the the Dependent Test Detection Problem is NP-complete.

\begin{theorem}
The problem of finding a test suite that manifests a dependence is
NP-hard.
\end{theorem}

\begin{proof}
%We prove this claim by reducing Exact Cover to Dependent Test
%Detection.
In the Exact Cover problem,
we are given a set $X$ = \{$x_1, x_2, x_3, \dots, x_m$\} and a collection $S$ of subsets of $X$.
The goal is to identify a sub-collection $S^*$ of $S$ such that \textit{each}
element in $X$ is contained in \textit{exactly} one subset in $S^*$.  

Assume a set $V = \{v_1, v_2, v_3, \dots, v_m\}$ of variables,
and a set $S = \{S_1, S_2, \dots, S_n\}$ with $S_i \subseteq V$ for $ 1\leq i
\leq n$. 

We now construct a tested program $P$, and a test suite
$T = \suite{t_1, t_2, \dots t_n , t_{n+1}}$ as follows:

\begin{itemize}

\item $P$ consists of $m$ global variables 
$v_1, v_2,\dots, v_m$, each with initial value 1.

\item 
For $1 \le i \le n$, $t_i$ is constructed as follows:
for $1 \le j \le m$, if $x_j \in S_i$, then adding a
single assignment statement \CodeIn{$v_j$ = $v_j$ - 1} to $t_i$.

$t_{n+1}$ consists only of the oracle
\CodeIn{assert($v_1$ != 0 || $v_2$ != 0 \dots || $v_m$ !=0)}.

\end{itemize}

In the above construction, the tests $t_i$ for $1 \le i \le n$ 
will always pass. The only
test that may fail and thus exhibit different behavior is $t_{n+1}$, which 
\emph{only} fails when each variable $v_i$ appears exactly
once in a test case.

For the given test $t_{n+1}$, if we can
find a sequence \suite{t_{i_1}, t_{i_2},\dots, t_{i_j}}
that makes $t_{n+1}$ fail, the subsets $S^*$ corresponding
to each $t_{i_j}$ are an exact cover of $V$.
\end{proof}

In practice, the structure of the proof directly translates to the
structure of test suites. $t_{n+1}$ is the dependent test, $S$ is
defined by the tests that write variables used by $t_{n+1}$, and every
exact cover of $S$ represents an independent shortest test suite that
is a manifest dependency of $t_{n+1}$.

To complete the proof that Dependent Test Detection is NP-complete, we
provide an algorithm to verify solutions to the problem, that is
linear in the size of the test suite.
Given a test suite $T$ and a test suite $S \subseteq T$ that is said
to manifest a dependency on $t_i$, we first execute $T$, then $S$, and
compare the result for $t_i$ in both executions. 
If the results differ the solution is correct, if they do not differ,
the solution is rejected.
Since in the worst case we have to execute $2n$ tests, the complexity
of this algorithm is linear.



%\subsection{Discussion}
%\label{sec:formaldiscussion}

%This formalism aims to lay a foundation for reasoning about
%test dependence in a precise way.
%The dynamic nature of view on dependences 
%allows us to avoid the complexity issues that come with a static
%approach. With a static approach, it would be essential 
%to decide how to address undecidability. The most
%likely and common approach being to choose soundness with respect to all
%possible executions and accepting the consequent imprecision of the analysis.
%Further, our focus on manifest dependence, when realized in a tool will
%only identify true positives, although it may miss some
%dependences (false negatives).  It is often easier to have tools
%with this kind of property accepted by practitioners than some other
%kinds.  

%Third, the manifest test dependence problem is NP-complete;
%although that is daunting (but less so than undecidability),
%approximate algorithms can be defined for large classes of NP-complete
%problems.  

%The examples in the following section and the algorithm and tool following that
%give a better flavor for
%why we made these decisions.
%The degree to which these are the ``right'' (or at least effective) decisions
%is itself an empirical
%question beyond the scope of this paper.

%.  The following section we will illustrate these factors in action.
%We discuss several examples in detail,
%showing how these different factors contribute to test dependence in
%real-world applications. 


%The potential for test dependence arises from the test structure and
%the oracle:
%%from the test results: 
%what
%global state do the tests read and write, and does that global state contribute
%to the computed result evaluated by the oracle?  
%At the same time, the \emph{potential} for a test dependence
%is realized only if 
%the values derived from the context \emph{actually} affect the test results.
%affect program state that
%is checked by the oracle can a dependence on the environment affect
%the outcome of a test.
%This potential \emph{manifests} when test results differ between
%executions in different environments.

%The fact that manifestation of test dependence depends on both test
%structures and test results means that dependences can silently propagate
%through sequences of tests before they become apparent.

%The abstract examples above, and the concrete examples presented 
%in Section~\ref{sec:examples} share some common features that
%ultimately lead to dependences. 
%%All applications and libraries we studied 
%They rely on global variables to some extent, and the
%tests that check behavior that depends on these variables usually
%assume these variables to be in some state. This state is typically
%defined by the default execution order of the test suite, and rarely
%established explicitly before each test.

%\todo{sz}{does that make sense to put the following text (needs slight revise)
% after Section 4. I feel they are more relevant to concrete examples.}

%To summarize, the features that contribute to the test dependences
%we discuss are:
%\begin{itemize}
%\item Test results depend on global state.
%\item Tests do not check their preconditions explicitly, but rely on
%the test suite to ensure them.
%%\item 
%%\todo{JW}{The following point has lead to a lot of confusion. We have
%to clarify or remove it}
%The strength of test oracles. Stronger oracles are more likely
%to cause dependence than weaker oracles. 
%%in the sense that they check for concrete
%%values rather than conditions. 
%For example, a check for $x = 5$
%rather than $x > 0$, is more likely to fail, while the latter might
%still be sufficient to check
%whether a specific branch of the program was executed. 
%\todo{KM}{I did not like
%this argument much. Though I agree that having weak oracles would reduce the
%dependences, it is still possible (in theory) to write dependent tests with
%weak oracles.}
%\end{itemize}



% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

