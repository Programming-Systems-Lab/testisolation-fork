\section{Tool Implementation}
\label{sec:impl}


We implemented our three dependent test detection algorithms in
a prototype tool, called \ourtool. \ourtool
supports JUnit 3.x/4.x tests. %, and is fully-automated.

\ourtool launches a fresh JVM when
executing a test permutation, ensuring there is no interaction between
different runs. When comparing the observed result of
a test in a permutation with its default result,
\ourtool considers two JUnit test results to be the same when the
tests either both pass, or exhibit exactly the same exception
(from the same line of code) or assertion violation.

%For the exhaustive $k$-bounded dependent test detection algorithm
%(Section~\ref{sec:basic}), \ourtool takes a test suite
%and the bounding parameter $k$ as inputs, 
%exhaustively executes every $k$-tuple
%of tests, and compares execution results to identify possible
%dependence tests.
 

To implement the dependence-aware $k$-bounded algorithm (Section~\ref{sec:advalgorithm}),
\ourtool uses ASM~\cite{asm} to perform load-time bytecode
instrumentation. Specifically, \ourtool inserts code to monitor each
static field access (including read and write). File accesses are
also monitored through installing a Java \code{SecurityManager} which provides 
read / write level information on files. Static field and file access are merged to produces a trace file for a \ourtool-instrumented test suite.

Mutable and immutable objects must be treated differently, as even a ``read'' access to a static
field will provide access to all the heap reachable from the object stored in that field. Such accesses must be treated as a read followed by a write. This issue seriously impacts the effectiveness of the dependency-aware algorithm. Classes known to only have immutable instances were provided as input to \ourtool. The instrumented Javari JDK provided by the Checker framework \cite{??}, classes marked as immutable by developer comments, and manual inspection of widely used classes (e.g., \code{java.awt.Color}, \code{java.util.Locale}) are the source of this information.

In practice many objects are not mutated even though this is not prohibited by the Java language (e.g., primitive arrays being used as constants). The algorithm was also instructed to ignore such fields, determined by manually inspecting fields which followed the Java naming convention of all-capital letters for constants, and fields commonly referenced by test code. 

In order to make the problem tractable, it was assumed that objects reachable from the static fields do not alias one another. This is important since in presence of aliasing, writing to one static field may effect others. This was not an issue in the subject programs we explored.

The other assumption made was that the JDK does not contain state itself, as the JDK was not instrumented. This is not entirely true and was an issue in \todo{explain this issue}. However, we believe this shortcoming is not fundamental and can be dealt with by  instrumenting static method calls to certain packages in the JDK.


%\ourtool also instruments
%calls to the \CodeIn{clone()} method and reflection
%methods, to record the objects they may create.
%\edit{a few sentences about security manager, and file accesses here}


%\edit{There are several sources of unsoundness in \ourtool's
%implementation. First, ...say the tradeoff in implementation here,
%such as dynamic class loading, native methods, etc....
%Despite these limitations, \ourtool works well in practice
%and identifies many real-world dependent tests (Section~\ref{sec:evaluation}).
%5}

%In addition, \ourtool implements the Delta debugging
%algorithm~\cite{Zeller:2002} to
%return the shortest sequence of tests that manifest a dependent test.
%This is useful to understand
%a manifested dependent test in a shuffled test suite.

The source code of \ourtool is available at:\\ \url{http://testisolation.googlecode.com}.

% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

%\todo{one improvement space: distinguish different values}

%\todo{I prefer to talk about file systems, optimizations
%that use user-provided annotations, the prefix of a permutation,
%and use multiple executions to
%guide selection in the implementation section.}

%  LocalWords:  ASM tradeoff
