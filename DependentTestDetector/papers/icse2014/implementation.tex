\section{Tool Implementation}
\label{sec:impl}


We implemented our three dependent test detection algorithms in
a prototype tool, called \ourtool. \ourtool
supports JUnit 3.x/4.x tests, and is fully-automated.

\ourtool launches a fresh JVM when
executing a shuffled test sutie or every
$k$-tuple of tests and clears external state such
as files, ensuring there is no interaction between
different runs. When comparing the observed result of
a test in an execution order with its default result,
\ourtool considers JUnit test results to be the same when the
tests either both pass, or exhibit exactly the same exception
or assertion violation.

%For the exhaustive $k$-bounded dependent test detection algorithm
%(Section~\ref{sec:basic}), \ourtool takes a test suite
%and the bounding parameter $k$ as inputs, 
%exhaustively executes every $k$-tuple
%of tests, and compares execution results to identify possible
%dependence tests.
 

To implement the dependence-aware $k$-bounded algorithm (Section~\ref{sec:advalgorithm}),
\ourtool uses ASM~\cite{asm} to perform load-time bytecode
instrumentation. Specifically, it inserts code to monitor each
field access (including read and write) by recording the
object ID and the field name. Each test produces a trace file after being
executed on a \ourtool-instrumented program.
%too low-level, commented out by Sai, an array object is also an object
%\ourtool also monitors array accesses by recording
%both the array object ID and the array index being accessed.
\ourtool uses two optimizations to reduce the
instrumentation overhead. First, accesses to objects
created by the test itself and disposed
after test execution, are not instrumented; since such 
objects are not accessible to other tests and thus can not
be the cause of test dependence. Second,
\ourtool does not instrument JDK classes. It uses the side-effect
annotations provided by Javarifier~\cite{QuinonezTE2008} to 
determine whether an object will be mutated or not.
Specifically, if a test uses an object as a mutable reference
in a Javarifier-annotated JDK call, \ourtool treats the test
has a write effect to the object.
\ourtool also instruments
calls to the \CodeIn{clone()} method and reflection
methods, to record the objects they may create.
\todo{a few sentences about security manager, and file accesses here}


There are several sources of unsoundness in \ourtool's
implementation. First, \todo{say the tradeoff in implementation here,
such as dynamic class loading, native methods, etc.}
Despite these limitations, \ourtool works well in practice
and identifies many real-world dependent tests (Section~\ref{sec:evaluation}).

In addition, \ourtool implements the Delta debugging
algorithm~\cite{Zeller:2002} to
return the shortest sequence of tests that manifest a dependent test.
This is useful to understand
a manifested dependent test in a shuffled test suite.
%randomized algorithm.

The source code of \ourtool is available at:\\ url{http://testisolation.googlecode.com}.

% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

%\todo{one improvement space: distinguish different values}

%\todo{I prefer to talk about file systems, optimizations
%that use user-provided annotations, the prefix of a permutation,
%and use multiple executions to
%guide selection in the implementation section.}
