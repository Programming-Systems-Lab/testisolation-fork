\section{Tool Implementation}
\label{sec:impl}


We implemented our dependent test detection algorithms in
a prototype tool. Our tool is fully-automated, and the
current implementation supports JUnit 3.x/4.x tests.
For the basic, $k$-bounded dependent test detection algorithm
(Section~\ref{sec:basic}), our tool takes a test suite
and the bounding parameter $k$ as inputs, 
exhaustively executes every $k$-tuple
of tests, and compares execution results to identify possible dependence cases. When
comparing the observed result of a test in an execution order with
its intended result,
We consider JUnit test results to be the same when the tests either
both pass, or exactly the same exception or assertion violation leads
to test failure.
The tool creates a fresh JVM for each \testlist, thus, ignoring
external state such as files and OS services, the environment
that the test suites are executed in is always the same $\env_0$.
This ensures that there is no interaction between
different \testlist\ through shared memory.

For the improved algorithm (Section~\ref{sec:advalgorithm}),
our tool uses ASM to dynamically instrument bytecode at 
class loading time. Each field access (read or write) is logged,
along with the ID of the object which is accessd. For array accesses,
both the object ID of the array and the index of the cell being accessed
are logged.

In order to acheive better performance, accesses to objects created
by the test itself were ignored, as such objects did not exist prior
to test exection, there could have been no dependency due to them.
Calls to constructors, .clone(), and also reflection methods which
return new objects were instrumented to obtain these objects (other ways for creating objects
may exist in Java, but this approximation sufficed).

Classes of the JDK itself were not instrumented. Rather, the annotated 
JDK provided with Javari \cite{??} was used as an approximation
to keep track of mutated objects. A read to an object which has been
mutated by a JDK call is treated as a potential \todo{?} dependency.
\todo{explain how this is unsound but we expect the JDK objects abstract
state not to depend on mutation of returned references.}


To log the files accessed by each test, a custom security manager was
implemented and installed before running the tests. 

File and memory access logs were then processed by a script to determine
dependencies according to the algorithm explained in \ref{sec:advalgorithm}.


Our prototype tool also implements the Delta debugging algorithm~\cite{Zeller:2002}
to return the shortest sequence of tests that manifest a dependency
for a given test $t_i$.

Our tool implementation is available at: \\\url{http://testisolation.googlecode.com}.


%However, due to the computational complexity of the general dependent test
%detection problem, it is difficult to know precisely how many dependent
%tests exist in a test suite. Thus, we do not
%yet have empirical data that shows how many percentages of dependence tests
%our tool can catch. Giving a reasonable estimation
%is one of our future work.

%we do not yet have strong empirical data that shows our algorithm catches X
%percentage or Y of the worst test dependences. It is one of our future work.


% The tool is publicly
% available\footnote{\url{http://testisolation.googlecode.com}}.
% The source code and user manual of our tool is publicly available at:
% \url{http://testisolation.googlecode.com}


% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

