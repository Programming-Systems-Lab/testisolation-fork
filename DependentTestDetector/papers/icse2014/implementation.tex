\section{Tool Implementation}
\label{sec:impl}


We implemented our four dependent test detection algorithms in
a tool called \ourtool. \ourtool
supports JUnit 3.x/4.x tests. %, and is fully-automated.

To ensure there is no interaction between
different runs, \ourtool launches a fresh JVM
when executing a test permutation, and after a run it resets resources,
such as deleting any temporary files that were created.
When comparing the observed result of
a test in a permutation with its expected result,
\ourtool considers two JUnit test results to be the same when both
tests pass, or when both tests exhibit exactly the same exception
or assertion violation, from the same line of code.

To implement the \dependenceaware{} $k$-bounded
algorithm, \ourtool uses ASM~\cite{asm} to perform load-time bytecode
instrumentation. \ourtool inserts code to monitor each
static field access (including read and write), and
monitors each file access by
installing a Java \code{SecurityManager} that provides 
file-level read/write information.
Each test produces a trace file containing both
field and file access information, after being executed
on a \ourtool-instrumented program. The \dependenceaware{} $k$-bounded
algorithm uses the recorded read/write information to detect
test dependence (Figure~\ref{fig:impralg}).
%Both field and file access information are recorded
%in a trace file after executing a \ourtool-instrumented test.

\ourtool conservatively treats both read
and write to a mutable static field as a write effect.
\ourtool assumes that the JDK is stateless,
and thus does not track field access in JDK classes. 
\ourtool does not perform any sophisticated points-to or shape
analyses. It uses the side-effect annotations
provided by Javari~\cite{QuinonezTE2008} to determine the immutable
classes. That is, if a method is annotated as side-effect-free
in Javari, \ourtool ignores all fields accessed by this method.


%\ourtool does not instrument JDK classes.
%It uses the side-effect annotations
%provided by the Javarifier~\cite{QuinonezTE2008} tool to determine whether
%an object will be mutated or not. If a test uses an object
%as a mutable reference in a Javarifier-annotated JDK call, \ourtool
%treats the test has a write effect to the object.
%For JDK classes not covered by
%Javarifier's annotations, \ourtool assumes these classes (and their object
%instances) are stateless. 

Optionally, a user can specify a
list of ``dependence-free''
fields (e.g., a static field for
logging or counting), which will not be considered
as the root cause of manifest test
dependence by \ourtool.
%\todo{Explain or reword ``can never be the root cause''.}
%\ourtool ignores accesses to these fields.

%In order to make the problem tractable, it was assumed that objects reachable from the static fields do not alias one another. 

%Mutable and immutable objects must be treated differently, as even a ``read'' access to a static
%field will provide access to all the heap reachable from the object stored in that field. Such accesses must be treated as a read followed by a write. This issue seriously impacts the effectiveness of the dependency-aware algorithm. Classes known to only have immutable instances were provided as input to \ourtool. The instrumented Javari JDK provided by the Checker framework \cite{??}, classes marked as immutable by developer comments, and manual inspection of widely used classes (e.g., \code{java.awt.Color}, \code{java.util.Locale}) are the source of this information.

%In practice many objects are not mutated even though this is not prohibited by the Java language (e.g., primitive arrays being used as constants). The algorithm was also instructed to ignore such fields, determined by manually inspecting fields which followed the Java naming convention of all-capital letters for constants, and fields commonly referenced by test code. 


%This is important since in presence of aliasing, writing to one static field may effect others. This was not an issue in the subject programs we explored.



%The other assumption made was that the JDK does not contain state itself, as the JDK was not instrumented. This is not entirely true and was an issue in \todo{explain this issue}. 


%\ourtool also instruments
%calls to the \CodeIn{clone()} method and reflection
%methods, to record the objects they may create.
%\edit{a few sentences about security manager, and file accesses here}

%In addition, \ourtool implements the Delta debugging
%algorithm~\cite{Zeller:2002} to
%return the shortest sequence of tests that manifest a dependent test.
%This is useful to understand
%a manifested dependent test in a shuffled test suite.

The source code of \ourtool is available at:\\ \url{http://testisolation.googlecode.com}.

% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

%\todo{one improvement space: distinguish different values}

%\todo{I prefer to talk about file systems, optimizations
%that use user-provided annotations, the prefix of a permutation,
%and use multiple executions to
%guide selection in the implementation section.}

%  LocalWords:  ASM tradeoff SecurityManager
