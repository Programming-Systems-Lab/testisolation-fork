\section{Tool Implementation}
\label{sec:impl}


We implemented our three dependent test detection algorithms in
a prototype tool, called \ourtool. \ourtool
supports JUnit 3.x/4.x tests. %, and is fully-automated.

\ourtool launches a fresh JVM
when executing a test permutation, ensuring there is no interaction between
different runs. When comparing the observed result of
a test in a permutation with its expected result,
\ourtool considers two JUnit test results to be the same when the
tests either both pass, or exhibit exactly the same exception
(from the same line of code) or assertion violation.

To implement the \dependenceaware{} $k$-bounded
algorithm, \ourtool uses ASM~\cite{asm} to perform load-time bytecode
instrumentation. \ourtool inserts code to monitor each
static field access (including read and write), and
monitors each file access by
installing a Java \code{SecurityManager} which provides 
file-level read/write information.
Each test produces a trace file containing both
field and file access information, after being executed
on a \ourtool-instrumented program.
%Both field and file access information are recorded
%in a trace file after executing a \ourtool-instrumented test.

\edit{check the text below}
\ourtool does not perform any sophisticated points-to or shape
analyses, rather, it conservatively treats both read
and write to a static field has a write effect,
since a read access to a static field may mutate objects
reachable from the field in the heap.
\ourtool assumes that the JDK is stateless,
and thus does not track field access in JDK classes. 


%\ourtool does not instrument JDK classes.
%It uses the side-effect annotations
%provided by the Javarifier~\cite{QuinonezTE2008} tool to determine whether
%an object will be mutated or not. If a test uses an object
%as a mutable reference in a Javarifier-annotated JDK call, \ourtool
%treats the test has a write effect to the object.
%For JDK classes not covered by
%Javarifier's annotations, \ourtool assumes these classes (and their object
%instances) are stateless. 

\ourtool uses the side-effect annotations
provided by Javari~\cite{QuinonezTE2008} to determine the immutable
static fields. Optionally, users can also specify a
list of ``dependence-free'' fields (e.g., a static field for
logging or counting), which can never be the root cause of manifest test dependence.
\ourtool ignores the accesses to these fields.

%In order to make the problem tractable, it was assumed that objects reachable from the static fields do not alias one another. 

%Mutable and immutable objects must be treated differently, as even a ``read'' access to a static
%field will provide access to all the heap reachable from the object stored in that field. Such accesses must be treated as a read followed by a write. This issue seriously impacts the effectiveness of the dependency-aware algorithm. Classes known to only have immutable instances were provided as input to \ourtool. The instrumented Javari JDK provided by the Checker framework \cite{??}, classes marked as immutable by developer comments, and manual inspection of widely used classes (e.g., \code{java.awt.Color}, \code{java.util.Locale}) are the source of this information.

%In practice many objects are not mutated even though this is not prohibited by the Java language (e.g., primitive arrays being used as constants). The algorithm was also instructed to ignore such fields, determined by manually inspecting fields which followed the Java naming convention of all-capital letters for constants, and fields commonly referenced by test code. 


%This is important since in presence of aliasing, writing to one static field may effect others. This was not an issue in the subject programs we explored.



%The other assumption made was that the JDK does not contain state itself, as the JDK was not instrumented. This is not entirely true and was an issue in \todo{explain this issue}. 


%\ourtool also instruments
%calls to the \CodeIn{clone()} method and reflection
%methods, to record the objects they may create.
%\edit{a few sentences about security manager, and file accesses here}

%In addition, \ourtool implements the Delta debugging
%algorithm~\cite{Zeller:2002} to
%return the shortest sequence of tests that manifest a dependent test.
%This is useful to understand
%a manifested dependent test in a shuffled test suite.

The source code of \ourtool is available at:\\ \url{http://testisolation.googlecode.com}.

% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

%\todo{one improvement space: distinguish different values}

%\todo{I prefer to talk about file systems, optimizations
%that use user-provided annotations, the prefix of a permutation,
%and use multiple executions to
%guide selection in the implementation section.}

%  LocalWords:  ASM tradeoff
