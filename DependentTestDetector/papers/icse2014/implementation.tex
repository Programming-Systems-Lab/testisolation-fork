\section{Tool Implementation}
\label{sec:impl}


We implemented our two dependent test detection algorithms in
a prototype tool, called \ourtool. \ourtool
supports JUnit 3.x/4.x tests, and is fully-automated.

For the basic, $k$-bounded dependent test detection algorithm
(Section~\ref{sec:basic}), \ourtool takes a test suite
and the bounding parameter $k$ as inputs, 
exhaustively executes every $k$-tuple
of tests, and compares execution results to identify possible
dependence tests. When
comparing the observed result of a test in an execution order with
its intended result,
\ourtool considers JUnit test results to be the same when the
tests either both pass, or exhibit exactly the same exception
or assertion violation.
\ourtool launches a fresh JVM when executing every
$k$-tuple of tests and clear external state such
as files, ensuring there is no interaction between
different runs. 

For the improved algorithm (Section~\ref{sec:advalgorithm}),
\ourtool uses ASM~\cite{asm} to perform load-time bytecode
instrumentation. Specifically, it inserts code to monitor each
field access (including read and write) by recording the
object ID and the field name.
\ourtool also monitors array accesses by recording
both the array object ID and the array index being accessed.
\ourtool uses two optimizations to reduce the
instrumentation overhead. First, accesses to objects
created by the test itself and disposed
after test execution, are not instrumented; since such 
objects are not accessible by other tests and thus can not
be the cause of test dependence. Second,
\ourtool does not instrument JDK classes. It uses the side-effect
annotations provided by Javarifier~\cite{QuinonezTE2008} to 
determine whether an object will be mutated or not.
Specifically, if a test uses an object as a mutable reference
in a Javarifier-annotated JDK call, \ourtool treats the test
has a write effect to the object, and thus adds a dependence
to the tests that only read that object. 
\ourtool also handles reflections. It instruments
calls to the \CodeIn{clone()} method and reflection
methods, to record the objects they may create.
File accesses are also monitored \todo{a few
sentenes about file accesses here}.

Each test produces a trace file after being
executed on a \ourtool-instrumented program. \ourtool
processes all trace files to identify potential
test dependencies based on the algorithm explained in
Section~\ref{sec:advalgorithm}.

Finally, for each group of tests that have potential
dependencies, \ourtool executes all possible permutations
to confirm the manifest dependence. \todo{confirm this
after finishing the tool.}


\todo{I would like to defer the unsound discussion introduced
by Javarifier to the end of experimental discussion}


In addition, \ourtool also implements the Delta debugging algorithm~\cite{Zeller:2002}
to return the shortest sequence of tests that manifest a dependency
for a given test.

Our tool implementation is available at: \\\url{http://testisolation.googlecode.com}.

% vim:wrap:wm=8:bs=2:expandtab:ts=4:tw=70:

