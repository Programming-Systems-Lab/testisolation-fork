\section{Detecting Dependent Tests}
\label{sec:detecting}

\newcommand{\smalltrialnum}{10\xspace}
\newcommand{\mediumtrialnum}{100\xspace}
\newcommand{\trialnum}{1000\xspace}

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}

An exhaustive search would execute all $n!$
permutations of the test suite to detect dependent tests.
However, this is not feasible for realistic $n$.
Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.

To approximate the exact solution, this section
presents three approximate algorithms that find a \textit{subset} of
all dependent tests.
%In this section we present two algorithms to detect dependent
%tests. 
Section~\ref{sec:randomized} describes a randomized algorithm
that repeatedly executes all the tests of a suite in random order.
Section~\ref{sec:basic} describes an exhaustive bounded algorithm that
executes all possible sequences of $k$ tests for a bounding parameter $k$.
Section~\ref{sec:advalgorithm} describes a dependence-aware $k-$bounded algorithm.
The dependence-aware algorithm dynamically collects the fields that each test
reads or writes, and uses such collected information to reduce the search space.
All algorithms are \textit{sound} but \textit{incomplete}:
every dependent test they find is real, but they do not
any guarantee to find every dependent test.

\subsection{Randomized Algorithm}
\label{sec:randomized}

\begin{figure}[t]
\textbf{Input}: a test suite $\mathit{T}$\\
\textbf{Output}: a set of dependent tests $\mathit{dependentTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$)}
\STATE $\mathit{execResults}$ $\leftarrow$ $\result{ts}{\env_0}$
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\mathit{dependentTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{dependentTests}$
%\ENDWHILE
\end{algorithmic}

% getPossibleExecOrder($T$, $k$): returns a set of test suites, each of size
% $\le k$; each suite is composed of tests selected from $T$ without replacement.\\

\vspace{-3mm}
\caption {The algorithm to detect dependent tests.
The getPossibleExecOrder function is instantiated
by different algorithms in Figures~\ref{fig:randalgorithm},
~\ref{fig:exhaustivealgorithm}, and~\ref{fig:impralg}.
}
\label{fig:basealgorithm}
\end{figure}


\begin{figure}[t]
getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\FOR{$i$ in 1..$\mathit{numtrials}$}
\STATE \textbf{yield} shuffle($T$)
\ENDFOR
\end{algorithmic}

\vspace{-3mm}
\caption {The randomized algorithm to detect dependent tests.
It uses the algorithm of Figure~\ref{fig:basealgorithm}, re-defining
the getPossibleExecOrder function.
Our experiments use $\mathit{numtrials} = \smalltrialnum,
\mediumtrialnum, \trialnum$.}
\label{fig:randalgorithm}
\end{figure}


Figure~\ref{fig:randalgorithm} shows the algorithm.
Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, this algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2).
Then, it randomizes the original
test execution order (line 3), and then executes each test
again to observe its result (line 4). The algorithm checks
whether the result of any test differs from the
expected result (lines 5--8). 

In our implementation, this algorithm repeatedly
shuffles the test suite, and executes each test until
no more dependent tests are identified within a
pre-defined number of iterations (default: \smalltrialnum iterations).
Our experiments use $\smalltrialnum,
\mediumtrialnum, \trialnum$ as the iteration numbers.

%\todo{How did we choose 10 iterations?  It might be good to try with some
%  different number such as 20 and report that there was no difference.
%  More generally, when choosing an arbitrary number, it adds credibility to
%  either give a justification for the number or to do an experiment to show
%  that the number is a reasonable choice.}


\subsection{Exhaustive Bounded Algorithm}
\label{sec:basic}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
kPermutations($T$, $k$): returns all $k$-permutations of $T$; that is, all
sequences of $k$ elements of $T$ without repetition

\medskip

getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\RETURN kPermutations($T$, $k$)
\end{algorithmic}

\vspace{-3mm}
\caption {The exhaustive $k$-bounded algorithm to detect dependent tests.
It uses the algorithm of Figure~\ref{fig:basealgorithm}, re-defining the
getPossibleExecOrder function.
%Our experiments use $k=1$ and $k=2$ to bound the length of
%test execution. 
} 
\label{fig:exhaustivealgorithm}
\end{figure}


%To detect all possible dependent tests, 

This algorithm uses the findings of our study
(Section~\ref{sec:study})
that most dependent tests can be found by running only short
subsequences of test suites. For example,
in our study, \pertange of the real-world dependent tests
can be found by running no more than 2 tests together.
Instead of executing all permutations of the
whole test suite, our algorithm (Figure~\ref{fig:exhaustivealgorithm})
executes all $k$-permutations for a bounding
parameter $k$.
By doing so, the algorithm reduces
the number of permutations to execute
to $O(n^k)$, which for small $k$ is tractable. 


Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, our algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2). 
It then executes every $k$-permutations of tests,
and checks whether the result of any test differs
from the expected result (lines 3--10). Finally, the algorithm returns the set
of all tests $t_i \in T$
that exhibit different results.





\subsection{Dependence-Aware Bounded Algorithm}
\label{sec:advalgorithm}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
recordFieldAccess($ts$): returns fields accessed (i.e., read and written) by each test in an ordered sequence of tests $ts$. \\
computeLastWrites($ts$, $reads$, $write$): for each field read by each test in $ts$, identify the last test in $ts$ that writes to the field.\\

\vspace{-2mm}

getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\langle reads, writes\rangle$ $\leftarrow$ recordFieldAccess($T$)\\
\COMMENT{$\mathit{reads}$ and $\mathit{writes}$'s data type:
  Map$\langle$Test, Set$\langle$Field$\rangle$$\rangle$
% which maps a test to a set of fields.
}
\STATE $\mathit{lastWrites}$ $\leftarrow$ computeLastWrites($T$, $\mathit{reads}$, $\mathit{writes}$)
\\\COMMENT{$\mathit{lastWrites}$'s data type: Map$\langle$Test, Map$\langle$Field, Test$\rangle$$\rangle$, which maps a test to fields it reads and
the corresponding last test that writes each field.}
\STATE $\mathit{result}$ $\leftarrow$ $\emptyset$
\FOR{each $\mathit{ts}$ in kPermutations($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{lastWriteTS}$ $\leftarrow$ computeLastWrites($ts$, $\mathit{reads}$, $\mathit{writes}$)
%\vspace{-3mm}
\IF{$\exists$ Test $\mathit{t} \in ts$ such that $\mathit{lastWrite}$[$t$] $\neq$ $\mathit{lastWriteTS}$[$t$]  }
\STATE $\mathit{result}$ $\leftarrow$ $\mathit{result} \cup \mathit{ts}$
\ENDIF
\ENDFOR
\RETURN $\mathit{result}$
\end{algorithmic}

\vspace{-3mm}
\caption {The dependence-aware $k$-bounded algorithm to detect dependent tests.
It uses the algorithm of Figure~\ref{fig:basealgorithm}, re-defining the
getPossibleExecOrder function.
%Our experiments uses $k=1$, \todo{experiment setting, how
%large k it can scale to.}. 
} 
\label{fig:impralg}
\end{figure}

\begin{figure}
\centering

\strut \hspace{-25mm} Initially: \code{x = y = 1;}

\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test1 \\  if(x == 0) \{ y = 0;\}\\ }
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test2\\ assert y == 1;}
\vspace{0.9em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test3\\ x = 0;}

\vspace{0.5em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test4 \\  if(x == 0) \{ y = 1;\}\\ }
\end{minipage}
}

\strut \hspace{-3mm} Field read and write information by each test when executing
in the order of Test1, Test2, Test3, and Test4.
\vspace{1mm}

\begin{tabular}{|c|l|l|l|l|}
%\toprule
\hline
\textbf{Global Fields } & \textbf{Test1} & \textbf{Test2} & \textbf{Test3}& \textbf{Test4}\\
\hline
\code{x} & Read & & Write& Read\\
\hline
\code{y} & & Read & &Write \\
\hline
\end{tabular}

\vspace{4mm}

Number of permutations that need to be executed.
\setlength{\tabcolsep}{1.3\tabcolsep}
\begin{tabular}{|c|c|c|}
%\toprule
\hline
\textbf{$k$ value} & \textbf{Exhaustive } &
\textbf{Dependence-Aware }  \\
\hline
1 & 4 & 1\\
\hline
2 & 12 & 5\\
\hline
3 & 24 & 18 \\
\hline
4 & 24 & 20 \\
\hline
\hline
\textbf{Total} & 64 & 44 \\
\hline
\end{tabular}


\Caption{Example tests to illustrate the dependence-aware
$k$-bounded dependent test detection algorithm (Figure~\ref{fig:impralg}).}
\label{fig:rwexample}
\end{figure}

%The exhaustive $k-$bounded algorithm cannot scale to a realistic test suite.
%For example, it would take months to 
%execute all 3-permutations
%in JodaTime's test suite (3875 tests, Table~\ref{tab:subjects}).

The dependence-aware $k$-bounded algorithm
detects the same number of dependent tests
as the exhaustive $k$-bounded algorithm (when using the same $k$),
but it uses dynamic analyses to improve efficiency.
It avoids executing test
permutations that are guaranteed to have the
same results as being executed in the default order.
The intuition of our algorithm is that,
given a test permutation, for \textit{each}
test, if \textit{all global fields} it reads
are written by the \textit{same} test as
in the default execution order, all tests in
the permutation are guaranteed to
have the same results and the permutation can be safely ignored. 

The algorithm in Figure~\ref{fig:impralg} redefines
the getPossibleExecOrder function in Figure~\ref{fig:basealgorithm}.
The redefined getPossibleExecOrder function first records
fields that each test reads and writes (line 1).
Then, for each field read by a test,
the function identifies the last test that writes
that field (line 3).
When generating all possible test permutations
up to length $k$, the algorithm checks whether
\textit{all} fields \textit{each} test (in the generated permutation)
may read are written by the same tests as in the
default order (lines 5--8). If so, all tests in the permutation
must produce the same results, and the algorithm discards
this permutation without executing it. Otherwise,
the function adds the generated permutation to the result
set (line 7), and runs the algorithm in Figure~\ref{fig:basealgorithm}
to identify dependent tests. %among it.
Due to space limit, we omit the proof of the correctness
of the dependence-aware $k$-bounded algorithm. Interested
readers can refer to~\cite{proof-dependence-aware} for details.

The dependence-aware $k$-bounded algorithm has two major benefits.
First, it clusters tests by the fields they
read and write. Thus, only tests reading or writing
the same global field(s), rather than \textit{all} tests
in a suite, are treated as potentially dependent.
Second, even for tests reading or writing the same global
field(s), some permutations can still be discarded
without executing by checking the tests performing the last write.

%in which every test must
%reveal the same result to reduce the total number
%of permutations which need to be explored.

To illustrate the second benefit, Figure~\ref{fig:rwexample}
shows an example
consisting of 2 global fields and 4 tests. In the default execution
order, Test 1 reads the \textit{initial} value of \code{x};
Test2 reads the \textit{initial} value of \code{y}, and Test4
reads the value of \code{x} written by Test3.
Based on such recorded information, when creating permutations with $k=1$,
our algorithm determines that only
Test4 needs to be executed, since Test4, if executed in isolation,
will read the \textit{initial} value of \code{x} rather than the \code{x}
value written by Test3. Similarly, when creating permutations with $k=2$,
only 5 out of 12 permutations ($\langle$Test1, Test4$\rangle$,
$\langle$Test2, Test4$\rangle$, $\langle$Test4, Test1$\rangle$,
$\langle$Test4, Test2$\rangle$, and $\langle$Test4, Test3$\rangle$) need to be executed.
Due to space limit, we omit test permutations when
$k=3$ and $k=4$, and list the number of permutations that need
to execute in Figure~\ref{fig:rwexample}.

%\todo{illustrate why simply group tests by read/write is incorrect.}


%\todo{give an intuition of why it can improve scalability, since
%not every test will overlap with each other.}



%In case a test $t_2$ does not potentially \todo{?} depend on a previously executed test $t_1$, this means 
%that all permutations of tests in which $t_2$ follows $t_1$ do not need to be considered for potential \todo{?} dependency
%given that all tests on which $t_1$ potentially \todo{?} depends on are present as a prefix of that permutation, 
%in the same order that the test suite was initially executed, thus reducing the number of permutations which
%need to be explored.


\begin{comment}

\edit{I add a simple proof below, which I am not happy with}

We next proof the correctness of the dependence-aware
$k$-bounded algorithm.

\begin{theorem}
All tests in a test permutation discarded by the getPossibleExecOrder
function (Figure~\ref{fig:impralg}) are guaranteed to produce the same results as in its default order.
\end{theorem}

\begin{proof}
We prove this theorem by contradiction. Given a test
suite $T$ and a test permutation $P$ of $T$, let's assume
permutation $P$ is discarded by the getPossibleExecOrder function
since all fields read by each test in $P$ are written
by the same test as in $T$.


Suppose there exists a test $t \in P$ produces a different result
than in $T$. Test $t$ must read a different value
for at least one shared field. Without loss of generality,
let's suppose $f$ is a shared field for which $t$ reads
a different value. Based on our assumption, 
$f$ is written by the same test, denoted as $t'$, as in $T$.
Since the $f$'s value is different in $P$, $t'$
must read different value for other shared fields.
By induction, there must exist a test $t'' \in P$ that 
reads a different \textit{initialization} value
for at least one shared field. This contradicts
the assumption that tests are executed in the same environment.
\edit{the above proof is not clear, need to
think about how to make it shorter and clearer.}
\end{proof}
\end{comment}
