\section{Detecting Dependent Tests}
\label{sec:detecting}

\newcommand{\smalltrialnum}{10\xspace}
\newcommand{\mediumtrialnum}{100\xspace}
\newcommand{\trialnum}{1000\xspace}

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}

%An exhaustive search would execute all $n!$
%permutations of the test suite to detect dependent tests.
%However, this is not feasible for realistic $n$.
Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.

To approximate the exact solution, this section
presents three approximate algorithms that find a \textit{subset} of
all dependent tests.
%In this section we present two algorithms to detect dependent
%tests. 
Section~\ref{sec:randomized} describes a randomized algorithm
that repeatedly executes all the tests of a suite in random order.
Section~\ref{sec:basic} describes an exhaustive bounded algorithm that
executes all possible sequences of $k$ tests for a bounding parameter $k$
(specified by the user).
Section~\ref{sec:advalgorithm} describes a \dependenceaware{} $k$-bounded algorithm.
The \dependenceaware{} algorithm dynamically collects the
static fields that each test
reads or writes, and uses the collected information to reduce the search space.
All three algorithms are \textit{sound} but \textit{incomplete}:
every dependent test they find is real, but they do not
guarantee to find every dependent test (unless the bound is $n$,
the size of the test suite).


\begin{figure}[t]
\textbf{Input}: a test suite $\mathit{T}$\\
\textbf{Output}: a set of dependent tests $\mathit{dependentTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$)}
\STATE $\mathit{execResults}$ $\leftarrow$ $\result{\mathit{ts}}{\env_0}$
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\mathit{dependentTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{dependentTests}$
%\ENDWHILE
\end{algorithmic}

% getPossibleExecOrder($T$, $k$): returns a set of test suites, each of size
% $\le k$; each suite is composed of tests selected from $T$ without replacement.\\

\vspace{-3mm}
\caption {The base algorithm to detect dependent tests.
The getPossibleExecOrder function is instantiated
by different algorithms in
Figures~\ref{fig:randalgorithm},~\ref{fig:exhaustivealgorithm},
and~\ref{fig:impralg}.
}
\label{fig:basealgorithm}
\end{figure}


\begin{figure}[t]
getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\FOR{$i$ in 1..$\mathit{numtrials}$}
\STATE \textbf{yield} shuffle($T$)
\ENDFOR
\end{algorithmic}

\vspace{-3mm}
\caption {The randomized algorithm to detect dependent tests.
It instantiates the algorithm of Figure~\ref{fig:basealgorithm}, defining
the getPossibleExecOrder function.
Our experiments use $\mathit{numtrials} = \smalltrialnum,
\mediumtrialnum, \trialnum$.}
\label{fig:randalgorithm}
\end{figure}


\subsection{Randomized Algorithm}
\label{sec:randomized}

Figure~\ref{fig:basealgorithm} shows the base algorithm.
%, and
Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, the base algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2).
It chooses some set of test suites (line 3), and then executes each test suite
to observe its results (line 4). The algorithm checks
whether the result of any test differs from the
expected result (lines 5--9). 

Figure~\ref{fig:randalgorithm} instantiates it for the
randomized algorithm by randomizing the original test execution order (line 2).
%(in this case, randomizations of the original
%test execution order 

%In our implementation, this algorithm repeatedly
%shuffles the test suite, and executes each test 
%for a pre-defined number of iterations.
%Our experiments use $\smalltrialnum,
%\mediumtrialnum, \trialnum$ as the iteration numbers.

%until
%no more dependent tests are identified within a
%pre-defined number of iterations. % (default: \smalltrialnum iterations).
%Our experiments use $\smalltrialnum,
%\mediumtrialnum, \trialnum$ as the iteration numbers.

%\todo{How did we choose 10 iterations?  It might be good to try with some
%  different number such as 20 and report that there was no difference.
%  More generally, when choosing an arbitrary number, it adds credibility to
%  either give a justification for the number or to do an experiment to show
%  that the number is a reasonable choice.}


\subsection{Exhaustive Bounded Algorithm}
\label{sec:basic}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
kPermutations($T$, $k$): returns all $k$-permutations of $T$; that is, all
sequences of $k$ distinct elements selected from $T$
\todo{any confusion of the above wording}\todo{You can leave it as is.}

\medskip

getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\RETURN kPermutations($T$, $k$)
\end{algorithmic}

\vspace{-3mm}
\caption {The exhaustive $k$-bounded algorithm to detect dependent tests.
It instantiates the algorithm of Figure~\ref{fig:basealgorithm}, defining the
getPossibleExecOrder function.
%Our experiments use $k=1$ and $k=2$ to bound the length of
%test execution. 
} 
\label{fig:exhaustivealgorithm}
\end{figure}


%To detect all possible dependent tests, 

This algorithm uses the findings of our study
(Section~\ref{sec:study})
that most dependent tests can be found by running only short
subsequences of test suites. For example,
in our study, \pertange of the real-world dependent tests
can be found by running no more than 2 tests together.
Instead of executing all permutations of the
whole test suite, our algorithm (Figure~\ref{fig:exhaustivealgorithm})
executes all $k$-permutations for a bounding
parameter $k$.
By doing so, the algorithm reduces
the number of permutations to execute
to $O(n^k)$, which is tractable for small $k$ and $n$. 


Figure~\ref{fig:exhaustivealgorithm} shows the algorithm.
%Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, the
%algorithm executes every $k$-permutation of tests,
%and checks whether the result of any test differs
%from the expected result. Finally, the algorithm returns the set
%of all tests $t_i \in T$
%that exhibit different results.





\subsection{Dependence-Aware Bounded Algorithm}
\label{sec:advalgorithm}

%\begin{figure}
%\centering
%
%\strut \hspace{-25mm} Initially: \code{x = y = 1;}
%
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test1 \\  if(x == 0) \{ y = 0;\}\\ }
%\end{minipage}
%}
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test2\\ assert y == 1;}
%\vspace{0.9em}
%\end{minipage}
%}
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test3\\ x = 0;}
%
%\vspace{0.5em}
%\end{minipage}
%}
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test4 \\  if(x == 0) \{ y = 1;\}\\ }
%\end{minipage}
%}
%
%\strut \hspace{-3mm} Field read and write information by each test when executing
%in the order of Test1, Test2, Test3, and Test4.
%\vspace{1mm}
%
%\begin{tabular}{|c|l|l|l|l|}
%\toprule
%\hline
%\textbf{Global Fields } & \textbf{Test1} & \textbf{Test2} & \textbf{Test3}& \textbf{Test4}\\
%\hline
%\code{x} & Read & & Write& Read\\
%\hline
%\code{y} & & Read & &Write \\
%\hline
%\end{tabular}
%
%\vspace{4mm}
%
%Number of permutations that need to be executed.
%\setlength{\tabcolsep}{1.3\tabcolsep}
%\begin{tabular}{|c|c|c|}
%\toprule
%\hline
%\textbf{$k$ value} & \textbf{Exhaustive } &
%\textbf{Dependence-Aware }  \\
%\hline
%1 & 4 & 1\\
%\hline
%2 & 12 & 5\\
%\hline
%3 & 24 & 18 \\
%\hline
%4 & 24 & 20 \\
%\hline
%\hline
%\textbf{Total} & 64 & 44 \\
%\hline
%\end{tabular}
%
%
%\Caption{Example tests to illustrate the \dependenceaware{}
%$k$-bounded dependent test detection algorithm (Figure~\ref{fig:impralg}).}
%\label{fig:rwexample}
%\end{figure}

%The exhaustive $k$-bounded algorithm cannot scale to a realistic test suite.
%For example, it would take months to 
%execute all 3-permutations
%in Joda-Time's test suite (3875 tests, Table~\ref{tab:subjects}).


The \dependenceaware{} $k$-bounded algorithm
detects the same number of dependent tests
as the exhaustive $k$-bounded algorithm does (when using the same $k$),
but it uses dynamic analyses to prune the search space.
%Information obtained from shorter permutations is used to avoid running lonnger permutations; 
%The algorithm first identifies all dependent tests
%that can be detected by running
%The algorithm first obtained the result of
%each test when executed in isolation.

Its key idea is to estimate which tests can interact through which fields
and to only run permutations in which the interactions may be different.
The algorithm determines, for every field read by a test, which test
previously wrote that field.
%(or that the field's value is unchanged from the
%initial environment).
If, in a permutation, all of those relationships are unchanged from the default
test order, then all the tests in that permutation give the same result as in the
default order (and, therefore, that permutation need not be run).  As a
special case, suppose that for each test,
\textit{every global field} (and other 
resources from the execution environment) it reads
is \textit{not} written by any test executed before it; then
each test in the permutation produces
the same result as when executed in isolation.
% (since each
% test does not interfere with any other tests).
Dependent tests whose isolation execution results
are different from the results in the default execution order
can be cheaply detected.
%and whether the isolation result is the same as
%the can be cheaply checked.). 
Thus, the permutation can be safely ignored. 

We give two cases for the algorithm:  an optimized version for $k$=1, and
a general version for $k$$\ge$2.

In the case of $k$=1, the algorithm executes all tests in the default order
within the same JVM. Any test that does \textit{not}
access (including read and write) any global fields or
other external resources such as a file is not a dependent test. 
The algorithm executes each of the remaining tests in isolation (i.e., in a
fresh JVM)
and reports the tests whose results are different than when executed in
the default order.

In the case of $k$$\ge$2, the algorithm first runs the case of $k$=1 (described above)
to find all dependent tests that exhibit different results
when executed in the default order and when executed in isolation.
Then, it runs the algorithm shown in Figure~\ref{fig:impralg}.
%
%\todo{Darioush, check the above,
%how could this permutation be safely ignored, if the result
%is only the same as in isolation (not the default order?)}
%The algorithm defines
%the getPossibleExecOrder function in Figure~\ref{fig:basealgorithm}.
The defined getPossibleExecOrder function first executes
each test in \textit{isolation}, and records the
fields that each test reads and writes (lines 1--3).
It uses the isolation execution result
of each test as a comparison baseline.
When generating all possible test permutations
of length $k$, the algorithm checks whether
\textit{all} global fields that \textit{each} test (in the generated permutation)
may read are not written by \textit{any} test executed before it (lines 6--10).
If so, all tests in the permutation
must produce the same results as executed in isolation,
and the algorithm can safely discard this permutation without
executing it. Otherwise, the algorithm adds the generated
permutation to the result set (line 9), and the algorithm in Figure~\ref{fig:basealgorithm}
identifies dependent tests. %among it.

%Due to space limits, we omit the proof of the correctness
We have proved the \dependenceaware{} $k$-bounded algorithm to be
correct. Interested
readers can refer to~\cite{proof-dependence-aware} for the proof.

The given algorithm uses isolated execution results as a baseline and
avoids executing permutations that are redundant with them.  It would be
possible to optimize the algorithm by adding each executed permutation to
the baseline and avoiding all redundant executions.  Such an algorithm is
more complex and we do not show it.

The \dependenceaware{} $k$-bounded algorithm has two major benefits.
First, it clusters tests by the fields they
read and write. Only tests reading or writing
the same global field(s), rather than \textit{all} tests
in a suite, are treated as potentially dependent.
Second, for tests reading or writing the same global
field(s), some permutations can be ignored by checking
the global fields each test may access. 

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
recordFieldAccess($\mathit{t}$): executes test $\mathit{t}$ in
a fresh JVM and returns the fields it reads and writes.\\
%by a test $t$. \\% in an ordered sequence of tests $\mathit{ts}$. \\


\vspace{-2mm}

getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\FOR { each $\mathit{t}$ in $\mathit{T}$ }
\STATE $\langle \mathit{reads}_t, \mathit{writes}_t\rangle$ $\leftarrow$ recordFieldAccess($\mathit{t}$)\\ 
\ENDFOR

\STATE $\mathit{result}$ $\leftarrow$ $\emptyset$ \\
\FOR{each $\mathit{ts}$ in kPermutations($\mathit{T}$, $\mathit{k}$)}
	\FOR {each $\mathit{t_i}$ in $\mathit{ts}$ \{ $\mathit{i}$ is the index of $\mathit{t_i}$ in $\mathit{ts}$ \}} 
		\STATE $\mathit{previousWrites}$ $\leftarrow$ $\bigcup_{\mathit{j} < \mathit{i}}  \mathit{writes}_{t_j} $ \\
		\IF {$\mathit{previousWrites} \cap \mathit{reads}_{t_i} \neq \emptyset$}
			\STATE $\mathit{result} \leftarrow \mathit{results} \cup \mathit{ts}$
		\ENDIF
	\ENDFOR

\ENDFOR
\RETURN $\mathit{result}$
\end{algorithmic}

\vspace{-3mm}
\caption {The \dependenceaware{} $k$-bounded algorithm to detect dependent tests,
  for $k$$\ge$2.
It instantiates the algorithm of Figure~\ref{fig:basealgorithm}, defining the
getPossibleExecOrder function.
For $k$=1, see Section~\ref{sec:advalgorithm}.
%Our experiments uses $k=1$, \todo{experiment setting, how
%large k it can scale to.}. 
} 
\label{fig:impralg}
\end{figure}


%in which every test must
%reveal the same result to reduce the total number
%of permutations which need to be explored.

%To better illustrate the second benefit, Figure~\ref{fig:rwexample}
%shows an example
%consisting of 2 global fields and 4 tests. In the default execution
%order, Test 1 reads the \textit{initial} value of \code{x};
%Test2 reads the \textit{initial} value of \code{y}, and Test4
%reads the value of \code{x} written by Test3.
%Based on such recorded information, when creating permutations with $k=1$,
%our algorithm determines that only
%Test4 needs to be executed, since Test4, if executed in isolation,
%will read the \textit{initial} value of \code{x} rather than the \code{x}
%value written by Test3. Similarly, when creating permutations with $k=2$,
%only 5 out of 12 permutations ($\langle$Test1, Test4$\rangle$,
%$\langle$Test2, Test4$\rangle$, $\langle$Test4, Test1$\rangle$,
%$\langle$Test4, Test2$\rangle$, and $\langle$Test4, Test3$\rangle$) need to be executed.
%Due to space limits, we omit test permutations when
%$k=3$ and $k=4$, and list the number of permutations that need
%to execute in Figure~\ref{fig:rwexample}.

%\todo{illustrate why simply group tests by read/write is incorrect.}


%\todo{give an intuition of why it can improve scalability, since
%not every test will overlap with each other.}



%In case a test $t_2$ does not potentially \todo{?} depend on a previously executed test $t_1$, this means 
%that all permutations of tests in which $t_2$ follows $t_1$ do not need to be considered for potential \todo{?} dependency
%given that all tests on which $t_1$ potentially \todo{?} depends on are present as a prefix of that permutation, 
%in the same order that the test suite was initially executed, thus reducing the number of permutations which
%need to be explored.


%\begin{comment}



%  LocalWords:  getPossibleExecOrder numtrials lastWriteTS previousWrites
%  LocalWords:  lastWrites
