\section{Detecting Dependent Tests}
\label{sec:detecting}

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
kPermutations($T$, $k$): returns all $k$-permutations of $T$; that is, all
sequences of $k$ elements of $T$ without repetition

\medskip

\textbf{Input}: a test suite $\mathit{T}$, an execution length $\mathit{k}$\\
\textbf{Output}: a set of dependent tests $\mathit{dependentTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{execResults}$ $\leftarrow$ $\result{ts}{\env_0}$
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\mathit{dependentTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{dependentTests}$
%\ENDWHILE
\end{algorithmic}

% getPossibleExecOrder($T$, $k$): returns a set of test suites, each of size
% $\le k$; each suite is composed of tests selected from $T$ without replacement.\\

\medskip

getPossibleExecOrder($T$, $k$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\RETURN kPermutations($T$, $k$)
\end{algorithmic}

\vspace{-3mm}
\caption {The exhaustive $k$-bounded algorithm to detect dependent tests.
Our experiments use $k=1$ and $k=2$ to bound the length of
test execution. } 
\label{fig:dtalgorithm}
\end{figure}

Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.
To approximate the solution, this section
presents two approximate algorithms.
%In this section we present two algorithms to detect dependent
%tests. 
Section~\ref{sec:basic} describes a basic algorithm that
exhaustively executes all possible $k$-test for a bounding parameter $k$
to detect dependent tests.
Section~\ref{sec:advalgorithm} described an improved algorithm
that uses program analyses to reduce the search space
\todo{describe some intuition here.}.
Both algorithms are \textit{sound} but \textit{incomplete}:
every dependent test they find is real, but they do not
any guarantee to find every dependent test.


\subsection{Basic Algorithm}
\label{sec:basic}

%To detect all possible dependent tests, 
An exhaustive search would execute all $n!$
permutations of the test suite to detect dependent tests.
However, this is not feasible for realistic $n$.
Our basic algorithm uses the findings of our study
(Section~\ref{sec:study})
that most dependent tests can be found by running only short
subsequences of test suites. For example,
in our study, \todo{}\% of the real-world dependent tests
can be found by running no more than 2 tests together.
Instead of executing all permutations of the
whole test suite, our algorithm (Figure~\ref{fig:dtalgorithm})
executes all possible $k$-tuples for a bounding
parameter $k$.
By doing so, the algorithm reduces
the number of permutations to execute
to $O(n^k)$, which for small $k$ is tractable. 


Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, our algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2). 
It then executes every $k$-tuple of tests,
and checks whether the result of any test differs
from the expected result (lines 3--10). Finally, the algorithm returns the set
of all tests $t_i \in T$
that exhibit different results.





\subsection{The Improved $k$-Bounded Algorithm}
\label{sec:advalgorithm}

\todo{I don't like ``improved'', which doesn't convey intuition.  Use a
  more descriptive term.}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
recordFieldAccess($ts$): returns fields accessed (i.e., read and written) by each test in an ordered sequence of tests $ts$. \\
computeLastWrites($ts$, $reads$, $write$): for each field read by each test in $ts$, identify the last test in $ts$ that writes to the field.\\


getPossibleExecOrder($T$, $k$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$\\
\COMMENT{$\mathit{reads}$ and $\mathit{writes}$'s data type:
  Map$\langle$Test, Set$\langle$Field$\rangle$$\rangle$
% which maps a test to a set of fields.
}\\
\STATE $\langle reads, writes\rangle$ $\leftarrow$ recordFieldAccess($T$)
\\\COMMENT{$\mathit{lastWrites}$'s data type: Map$\langle$Test, Map$\langle$Field, Test$\rangle$$\rangle$, which maps a test to fields it reads and
the corresponding last test that writes each field.}
\STATE $\mathit{lastWrites}$ $\leftarrow$ computeLastWrites($T$, $\mathit{reads}$, $\mathit{writes}$)
\STATE $\mathit{result}$ $\leftarrow$ $\emptyset$
\FOR{each $\mathit{ts}$ in kPermutations($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{lastWriteTS}$ $\leftarrow$ computeLastWrites($ts$, $\mathit{reads}$, $\mathit{writes}$)
\vspace{-3mm}
\IF{$\exists$ Test $\mathit{t} \in ts$ such that $\mathit{lastWrite}$[$t$] $\neq$ $\mathit{lastWriteTS}$[$t$]  }
\STATE $\mathit{result}$ $\leftarrow$ $\mathit{result} \cup \mathit{ts}$
\ENDIF
\ENDFOR
\RETURN $\mathit{result}$
\end{algorithmic}

\vspace{-3mm}
\caption {The improved algorithm to detect dependent tests.
It uses the algorithm of Figure~\ref{fig:dtalgorithm}, re-defining the
getPossibleExecOrder function.
Our experiments uses $k=1$, \todo{experiment setting, how
large k it can scale to.}. } 
\label{fig:impralg}
\end{figure}

\begin{figure}
\centering

\strut \hspace{-25mm} Initially: \code{x = y = 1;}

\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test1 \\  if(x == 0) \{ y = 0;\}\\ }
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test2\\ assert y == 1;}
\vspace{0.9em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test3\\ x = 0;}

\vspace{0.5em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test4 \\  if(x == 0) \{ y = 1;\}\\ }
\end{minipage}
}

\strut \hspace{-3mm} Field read and write information by each test when executing
in the order of Test1, Test2, Test3, and Test4.
\vspace{1mm}

\begin{tabular}{|c|l|l|l|l|}
%\toprule
\hline
\textbf{Shared Fields } & \textbf{Test1} & \textbf{Test2} & \textbf{Test3}& \textbf{Test4}\\
\hline
\code{x} & Read & & Write& Read\\
\hline
\code{y} & & Read & &Write \\
\hline
\end{tabular}

\vspace{4mm}

Number of permutations that need to be executed.
\setlength{\tabcolsep}{0.5\tabcolsep}
\begin{tabular}{|c|c|c|}
%\toprule
\hline
\textbf{$k$ value} & \textbf{Basic Algorithm} & \textbf{Improved Algorithm}  \\
\hline
1 & 4 & 1\\
\hline
2 & 12 & 5\\
\hline
3 & 24 & \todo{xx} \\
\hline
4 & 24 & \todo{xx} \\
\hline
\textbf{Total} & 64 & \todo{xx} \\
\hline
\end{tabular}


\Caption{Example tests to illustrate the improved
dependent test detection algorithm (Figure~\ref{fig:impralg}).}
\label{fig:rwexample}
\end{figure}

Although the basic algorithm bounds the
number of possible permutations to $O(n^k)$,
it cannot scale to a realistic test suite.
For example, using $k=3$, the time for
executing all possible test permutations
in JodaTime's test suite (3875 tests, Table~\ref{tab:subjects})
is measured by months.

To reduce the search space, our improved algorithm
uses dynamic analyses to avoid executing test
permutations that are guaranteed to have the
same results as being executed in the default order.
The intuition of our algorithm is that,
given a test permutation, for \textit{each}
test, if \textit{all shared fields} 
\todo{is it ok that shared fields are not defined,
shoiuld we use global fields?} it reads
are written by the \textit{same} test as
in the default execution order, all tests in
the permutation are guaranteed to
have the same results and the permutation can be safely ignored. 

The improved algorithm (Figure~\ref{fig:impralg}) takes the same
input as the basic algorithm. It first executes the whole
test suite in its default order
to record test execution results (line 2) as
well as fields that each test reads and writes (line 3).
Then, for each field read by a test,
the algorithm identifies the last test that writes
that field (line 4).
After that, the algorithm generates all possible test permutations
up to length $k$. Before executing each permutation, 
the algorithm checks whether all fields a test may read are written
by the same tests as in the default order (lines 6--9).
If so, the algorithm concludes that all tests in the permutation
must reveal the same results. Otherwise,
it executes the permutation and records the tests with
different execution results. Lines 10---15 in Figure~\ref{fig:impralg}
are the same to lines 4---9 in Figure~\ref{fig:dtalgorithm}.

\todo{do we need a proof here.}

%in which every test must
%reveal the same result to reduce the total number
%of permutations which need to be explored.

To illustrate this algorithm, Figure~\ref{fig:rwexample} shows an example
consisting of 2 shared fields and 4 tests. In the default execution
order, Test 1 reads the \textit{initial} value of \code{x};
Test2 reads the \textit{initial} value of \code{y}, and Test4
reads the value of \code{x} written by Test3.
Based on such recorded information, when creating permutations with $k=1$,
our algorithm determines that only
Test4 needs to be executed, since Test4, if executed in isolation,
will read the \textit{initial} value of \code{x} rather than the \code{x}
value written by Test3. Similarly, when creating permutations with $k=2$,
only 5 out of 12 permutations ($\langle$Test1, Test4$\rangle$,
$\langle$Test2, Test4$\rangle$, $\langle$Test4, Test1$\rangle$,
$\langle$Test4, Test2$\rangle$, and $\langle$Test4, Test3$\rangle$) need to be executed.
Due to space limitation, we omit details of test executions when
$k=3$ and $k=4$, and lists the number of permutations that need
to execute in Figure~\ref{fig:rwexample}.

Another huge saving resulting from this algorithm, as observed in our
experiments, is that it classifies tests by the fields they
read and write. Thus, only tests reading or writing at
least one shared field, rather than \textit{all} tests, are treated as potentially
dependent.

\todo{should mention that this algorithm is quite conservation,
and why it is correct. We ignore write}

\todo{illustrate why simply group tests by read/write is incorrect.}

\todo{one improvement space: distinguish different values}

\todo{give an intuition of why it can improve scalability, since
not every test will overlap with each other.}



%In case a test $t_2$ does not potentially \todo{?} depend on a previously executed test $t_1$, this means 
%that all permutations of tests in which $t_2$ follows $t_1$ do not need to be considered for potential \todo{?} dependency
%given that all tests on which $t_1$ potentially \todo{?} depends on are present as a prefix of that permutation, 
%in the same order that the test suite was initially executed, thus reducing the number of permutations which
%need to be explored.

\todo{I prefer to talk about file systems, optimizations
that use user-provided annotations, the prefix of a permutation,
and use multiple executions to
guide selection in the implementation section.}
