\section{Detecting Dependent Tests}
\label{sec:detecting}

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
kPermutations($T$, $k$): returns all $k$-permutations of $T$; that is, all
sequences of $k$ elements of $T$ without repetition

\medskip

\textbf{Input}: a test suite $\mathit{T}$, an execution length $\mathit{k}$\\
\textbf{Output}: a set of dependent tests $\mathit{dependentTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{execResults}$ $\leftarrow$ $\result{ts}{\env_0}$
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\mathit{dependentTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{dependentTests}$
%\ENDWHILE
\end{algorithmic}

% getPossibleExecOrder($T$, $k$): returns a set of test suites, each of size
% $\le k$; each suite is composed of tests selected from $T$ without replacement.\\

\medskip

getPossibleExecOrder($T$, $k$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\RETURN kPermutations($T$, $k$)
\end{algorithmic}

\vspace{-3mm}
\caption {The exhaustive $k$-bounded algorithm to detect dependent tests.
Our experiments use $k=1$ and $k=2$ to bound the length of
test execution. } 
\label{fig:dtalgorithm}
\end{figure}
An exhaustive search would execute all $n!$
permutations of the test suite to detect dependent tests.
However, this is not feasible for realistic $n$.
Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.

To approximate the exact solution, this section
presents two approximate algorithms that find a \textit{subset} of
all dependent tests.
%In this section we present two algorithms to detect dependent
%tests. 
Section~\ref{sec:basic} describes an exhaustive $k-$bounded algorithm that
executes all possible $k$-test for a bounding parameter $k$
to detect dependent tests.
Section~\ref{sec:advalgorithm} describes an improved $k-$bounded algorithm.
The improved algorithm dynamically collected the fields that each test
reads or writes, and uses such collected information to reduce the search space.
\edit{I edit the above sentence.}
Both algorithms are \textit{sound} but \textit{incomplete}:
every dependent test they find is real, but they do not
any guarantee to find every dependent test.


\subsection{Exhausitive $k-$bounded Algorithm}
\label{sec:basic}

%To detect all possible dependent tests, 

Our basic algorithm uses the findings of our study
(Section~\ref{sec:study})
that most dependent tests can be found by running only short
subsequences of test suites. For example,
in our study, \pertange of the real-world dependent tests
can be found by running no more than 2 tests together.
Instead of executing all permutations of the
whole test suite, our algorithm (Figure~\ref{fig:dtalgorithm})
executes all $k$-permutations for a bounding
parameter $k$.
By doing so, the algorithm reduces
the number of permutations to execute
to $O(n^k)$, which for small $k$ is tractable. 


Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, our algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2). 
It then executes every $k$-permutations of tests,
and checks whether the result of any test differs
from the expected result (lines 3--10). Finally, the algorithm returns the set
of all tests $t_i \in T$
that exhibit different results.





\subsection{Improved $k$-Bounded Algorithm}
\label{sec:advalgorithm}

%\todo{I don't like ``improved'', which doesn't convey intuition.  Use a
%  more descriptive term.}
\edit{What about "Dependence-Guided $k$-bounded algorithm"}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
recordFieldAccess($ts$): returns fields accessed (i.e., read and written) by each test in an ordered sequence of tests $ts$. \\
computeLastWrites($ts$, $reads$, $write$): for each field read by each test in $ts$, identify the last test in $ts$ that writes to the field.\\

\vspace{-2mm}

getPossibleExecOrder($T$, $k$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$\\
\COMMENT{$\mathit{reads}$ and $\mathit{writes}$'s data type:
  Map$\langle$Test, Set$\langle$Field$\rangle$$\rangle$
% which maps a test to a set of fields.
}\\
\STATE $\langle reads, writes\rangle$ $\leftarrow$ recordFieldAccess($T$)
\\\COMMENT{$\mathit{lastWrites}$'s data type: Map$\langle$Test, Map$\langle$Field, Test$\rangle$$\rangle$, which maps a test to fields it reads and
the corresponding last test that writes each field.}
\STATE $\mathit{lastWrites}$ $\leftarrow$ computeLastWrites($T$, $\mathit{reads}$, $\mathit{writes}$)
\STATE $\mathit{result}$ $\leftarrow$ $\emptyset$
\FOR{each $\mathit{ts}$ in kPermutations($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{lastWriteTS}$ $\leftarrow$ computeLastWrites($ts$, $\mathit{reads}$, $\mathit{writes}$)
\vspace{-3mm}
\IF{$\exists$ Test $\mathit{t} \in ts$ such that $\mathit{lastWrite}$[$t$] $\neq$ $\mathit{lastWriteTS}$[$t$]  }
\STATE $\mathit{result}$ $\leftarrow$ $\mathit{result} \cup \mathit{ts}$
\ENDIF
\ENDFOR
\RETURN $\mathit{result}$
\end{algorithmic}

\vspace{-3mm}
\caption {The improved algorithm to detect dependent tests.
It uses the algorithm of Figure~\ref{fig:dtalgorithm}, re-defining the
getPossibleExecOrder function.
Our experiments uses $k=1$, \todo{experiment setting, how
large k it can scale to.}. } 
\label{fig:impralg}
\end{figure}

\begin{figure}
\centering

\strut \hspace{-25mm} Initially: \code{x = y = 1;}

\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test1 \\  if(x == 0) \{ y = 0;\}\\ }
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test2\\ assert y == 1;}
\vspace{0.9em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test3\\ x = 0;}

\vspace{0.5em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test4 \\  if(x == 0) \{ y = 1;\}\\ }
\end{minipage}
}

\strut \hspace{-3mm} Field read and write information by each test when executing
in the order of Test1, Test2, Test3, and Test4.
\vspace{1mm}

\begin{tabular}{|c|l|l|l|l|}
%\toprule
\hline
\textbf{Global Fields } & \textbf{Test1} & \textbf{Test2} & \textbf{Test3}& \textbf{Test4}\\
\hline
\code{x} & Read & & Write& Read\\
\hline
\code{y} & & Read & &Write \\
\hline
\end{tabular}

\vspace{4mm}

Number of permutations that need to be executed.
\setlength{\tabcolsep}{0.5\tabcolsep}
\begin{tabular}{|c|c|c|}
%\toprule
\hline
\textbf{$k$ value} & \textbf{Basic Algorithm} & \textbf{Improved Algorithm}  \\
\hline
1 & 4 & 1\\
\hline
2 & 12 & 5\\
\hline
3 & 24 & 18 \\
\hline
4 & 24 & 20 \\
\hline
\hline
\textbf{Total} & 64 & 44 \\
\hline
\end{tabular}


\Caption{Example tests to illustrate the improved
dependent test detection algorithm (Figure~\ref{fig:impralg}).}
\label{fig:rwexample}
\end{figure}

The exhaustive $k-$bounded algorithm cannot scale to a realistic test suite.
For example, it would take months to 
execute all 3-permutations
in JodaTime's test suite (3875 tests, Table~\ref{tab:subjects}).

To reduce the search space, our improved algorithm
uses dynamic analyses to avoid executing test
permutations that are guaranteed to have the
same results as being executed in the default order.
The intuition of our algorithm is that,
given a test permutation, for \textit{each}
test, if \textit{all global fields} it reads
are written by the \textit{same} test as
in the default execution order, all tests in
the permutation are guaranteed to
have the same results and the permutation can be safely ignored. 

\edit{I edit the text below}
The algorithm in Figure~\ref{fig:impralg} uses the
algorithm of Figure~\ref{fig:dtalgorithm}, by redefining
the getPossibleExecOrder function. The redefined
getPossibleExecOrder function first records
the test execution results (line 1) and
and fields that each test reads and writes (line 2).
Then, for each field read by a test,
the function identifies the last test that writes
that field (line 4).
Whe generating all possible test permutations
up to length $k$, the algorithm checks whether
all fields each test (in the generated permuation)
may read are written by the same tests as in the
default order (lines 6--9). If so, all tests in the permutation
must produce the same results, and the algorithm discards
this permutation without executing it. Otherwise,
the function adds the generated permutation to the result
set (line 8), and runs the algorithm in Figure~\ref{fig:dtalgorithm}
to identify dependent tests among it.

\edit{I add a simple proof below}

We next proof the correctness of the improved $k$-bounded algorithm.

\begin{theorem}
All tests in a test permutation discarded by the getPossibleExecOrder
function (Figure~\ref{fig:impralg}) are guaranteed to produce the same results as in its default order.
\end{theorem}

\begin{proof}
We prove this theorem by contradiction. Given a test
suite $T$ and a test permutation $P$ of $T$, let's assume
permutation $P$ is discarded by the getPossibleExecOrder function
since all fields read by each test in $P$ are written
by the same test as in $T$.


Suppose there exists a test $t \in P$ produces a different result
than in $T$. Test $t$ must read different values
for at least one shared field. Based on our assumption,
the shared field is written by the same test as in $T$,
but the test reads different values for at least
one shared field. By induction, there must exist
a test $t' \in P$ that 
\edit{the above proof is not finished, need to
think about how to make it shorter.}
\end{proof}

\edit{I edited text below}
The improved $k$-bounded algorithm has two major benefits.
First, it clusters tests by the fields they
read and write. Thus, only tests reading or writing at
the same global field(s), rather than \textit{all} tests
in a suite, are treated as potentially dependent.
Second, even for tests reading or writing the same global
field(s), some permutations can still be discarded
without executing by checking the tests performing the last write.

%in which every test must
%reveal the same result to reduce the total number
%of permutations which need to be explored.

To illustrate the second benefit, Figure~\ref{fig:rwexample}
shows an example
consisting of 2 global fields and 4 tests. In the default execution
order, Test 1 reads the \textit{initial} value of \code{x};
Test2 reads the \textit{initial} value of \code{y}, and Test4
reads the value of \code{x} written by Test3.
Based on such recorded information, when creating permutations with $k=1$,
our algorithm determines that only
Test4 needs to be executed, since Test4, if executed in isolation,
will read the \textit{initial} value of \code{x} rather than the \code{x}
value written by Test3. Similarly, when creating permutations with $k=2$,
only 5 out of 12 permutations ($\langle$Test1, Test4$\rangle$,
$\langle$Test2, Test4$\rangle$, $\langle$Test4, Test1$\rangle$,
$\langle$Test4, Test2$\rangle$, and $\langle$Test4, Test3$\rangle$) need to be executed.
Due to space limitation, we omit details of test executions when
$k=3$ and $k=4$, and lists the number of permutations that need
to execute in Figure~\ref{fig:rwexample}.

%\todo{illustrate why simply group tests by read/write is incorrect.}


%\todo{give an intuition of why it can improve scalability, since
%not every test will overlap with each other.}



%In case a test $t_2$ does not potentially \todo{?} depend on a previously executed test $t_1$, this means 
%that all permutations of tests in which $t_2$ follows $t_1$ do not need to be considered for potential \todo{?} dependency
%given that all tests on which $t_1$ potentially \todo{?} depends on are present as a prefix of that permutation, 
%in the same order that the test suite was initially executed, thus reducing the number of permutations which
%need to be explored.


