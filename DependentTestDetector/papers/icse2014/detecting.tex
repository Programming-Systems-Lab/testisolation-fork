\section{Detecting Dependent Tests}
\label{sec:detecting}

In this section we present two algorithms to detect dependent
tests. Section~\ref{sec:basic} describes a basic algorithm that
exhaustively executes all possible $k$-test for a bounding parameter $k$
to detect dependent
tests. Section~\ref{sec:advalgorithm} described an improved algorithm
that uses program analyses to reduce the search space\todo{should we say more about the
second algorithm here?}.




\subsection{Basic Algorithm}
\label{sec:basic}


%To detect all possible dependent tests, 
A naive, exhaustive search would execute all $n!$
permutations of the test suite to detect dependent tests. While this
is not feasible for realistic $n$, our approximate algorithm uses 
the findings of our study (Section~\ref{sec:study})
that many dependences can be found by running only short subsequences of
test suites, and introduces a bound $k$ on the length
of subsequences. That effectively bounds the execution time to
$O(n^k)$, which for small $k$ is tractable. At the same time, our
prototype tool and the experiments we conducted with it, suggest that
many dependences can be found for small $k$.

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}
Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.
Instead, we developed an algorithm to approximate solutions by
detecting a subset of dependent
tests. %, focusing on specific, less-general forms of the problem. 
For tractability, our algorithm in Figure~\ref{fig:dtalgorithm} bounds the length of
test execution sequences, and thus the number of permutations to
execute. Instead of executing all permutations of the
whole test suite, we execute all possible $k$-tuples for a bounding
parameter $k$.

Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, our algorithm
executes $\exec{T}{\env_0}$ to obtain the \emph{expected result}
$\result{T}{\env_0}$ of each test (line 2). The environment $\env_0$
is the environment provided by the test execution framework.
It then executes every $k$-tuple \testlist\ of tests as
$\exec{\testlist}{\env_0}$, and 
checks whether any result $\result{\testlist}{\env_0}$ differs
from the expected result, i.e.
that there is a dependence in $\testlist$
(lines 3--10). The algorithm returns the set of all tests $t_i \in T$
that have at least one dependence.



\begin{figure}[t]
\textbf{Input}: a test suite $\mathit{T}$, an execution length $\mathit{k}$\\
\textbf{Output}: a set of dependent tests $\mathit{depTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{depTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$
 \executeTestsInOrder{T}
\FOR{each $\testlist$ in getPossibleExecOrder($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{execResults}$ $\leftarrow$
\executeTestsInOrder{\testlist}
\FOR{each test $\mathit{t}$ in $\testlist$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{depTests}$ $\leftarrow$ $\mathit{depTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{depTests}$
%\ENDWHILE
\end{algorithmic}
\vspace{-3mm}
\caption{$k$-bounded approximation algorithm to detect dependent
tests. 
``getPossibleExecOrder'' returns all permutations of tests from $T$ of length $k$. 
} 
\label{fig:dtalgorithm}
\end{figure}


\subsection{The Improved Algorithm}
\label{sec:advalgorithm}

\todo{describe Darioush's algorithm here. This algorithms use
static/dynamic program analyses to reduce search space}
