\section{Detecting Dependent Tests}
\label{sec:detecting}

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
getPossibleExecOrder($T$, $k$): returns all permutations of tests from a test suite $T$ of length $k$.\\
executeTests($ts$): executes a list of tests $ts$ 
on the initial environment provided by the test execution framework.
and returns the execution results.\\
\textbf{Input}: a test suite $\mathit{T}$, an execution length $\mathit{k}$\\
\textbf{Output}: a set of dependent tests $\mathit{depTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{depTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ executeTests($T$)
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{execResults}$ $\leftarrow$ executeTests($ts$)
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{depTests}$ $\leftarrow$ $\mathit{depTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{depTests}$
%\ENDWHILE
\end{algorithmic}
\vspace{-3mm}
\caption {The basic algorithm to detect dependent tests.
It introduces a parameter $k$ to bound the length of
test execution. Our experiments uses $k=1$ and $k=2$. } 
\label{fig:dtalgorithm}
\end{figure}

Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.
In this section, we present two approximate algorithms to detect
a subset of dependent tests. 
%In this section we present two algorithms to detect dependent
%tests. 
Section~\ref{sec:basic} describes a basic algorithm that
exhaustively executes all possible $k$-test for a bounding parameter $k$
to detect dependent
tests. Section~\ref{sec:advalgorithm} described an improved algorithm
that uses program analyses to reduce the search space
\todo{describe some intuition here.}.


\subsection{Basic Algorithm}
\label{sec:basic}

%To detect all possible dependent tests, 
An exhaustive search would execute all $n!$
permutations of the test suite to detect dependent tests.
However, this is not feasible for realistic $n$.
Our basic algorithm uses the findings of our study
(Section~\ref{sec:study})
that most dependent tests can be found by running only short
subsequences of test suites. 
Instead of executing all permutations of the
whole test suite, our algorithm (Figure~\ref{fig:dtalgorithm})
executes all possible $k$-tuples for a bounding
parameter $k$.
Thus, the number of permutations to execute
is $O(n^k)$, which for small $k$ is tractable. 


Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, our algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2). 
It then executes every $k$-tuple of tests,
and checks whether the result of any test differs
from the expected result (lines 3--10). The algorithm returns the set
of all tests $t_i \in T$
that exhibit different results.





\subsection{The Improved Algorithm}
\label{sec:advalgorithm}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
recordFieldAccess($ts$): returns fields accessed (including read and write) by each test in a test permutation $ts$. \\
computeLastWrites($ts$, $reads$, $write$): for each field read by each test in $ts$, identify the test in $ts$ that writes to the field.\\
\textbf{Input}: a test suite $\mathit{T}$, an execution length $\mathit{k}$\\
\textbf{Output}: a set of dependent tests $\mathit{depTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{depTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ executeTests($T$)\\
\COMMENT{$\mathit{reads}$ and $\mathit{writes}$'s data type: Map$\langle$Test, Set$\langle$Field$\rangle$$\rangle$}
\STATE $\langle reads, writes\rangle$ $\leftarrow$ recordFieldAccess($T$)
\\\COMMENT{$\mathit{lastWrites}$'s data type: Map$\langle$Test, Map$\langle$Field, Test$\rangle$$\rangle$}
\STATE $\mathit{lastWrites}$ $\leftarrow$ computeLastWrites($T$, $\mathit{reads}$, $\mathit{writes}$)
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$, $\mathit{k}$)}
\STATE $\mathit{lastWriteTS}$ $\leftarrow$ computeLastWrites($ts$, $\mathit{reads}$, $\mathit{writes}$)
\vspace{-3mm}
\IF{$\exists$ Test $\mathit{t} \in ts$ that $\mathit{lastWrite}$[$t$] $\neq$ $\mathit{lastWriteTS}$[$t$]  }
\STATE \textbf{continue}
\ENDIF
\STATE $\mathit{execResults}$ $\leftarrow$ executeTests($\mathit{ts}$)
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{depTests}$ $\leftarrow$ $\mathit{depTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{depTests}$
%\ENDWHILE
\end{algorithmic}
\vspace{-3mm}
\caption {The improved algorithm to detect dependent tests.
Auxiliary methods getPossibleExecOrder and executeTests are
defined in Figure~\ref{fig:dtalgorithm}.
Our experiments uses $k=1$, \todo{experiment results.} } 
\todo{may have some inconsistency not fixed above}
\label{fig:impralg}
\end{figure}

\begin{figure}
\centering

\strut \hspace{-25mm} Initially: \code{x = y = 1;}

\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test1 \\  if(x == 0) \{ y = 0;\}\\ }
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test2\\ assert y == 1;}
\vspace{0.9em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test3\\ x = 0;}

\vspace{0.5em}
\end{minipage}
}
\subfigure{
\begin{minipage}{.43\columnwidth}
\code{Test4 \\  if(x == 0) \{ y = 1;\}\\ }
\end{minipage}
}

\strut \hspace{-3mm} Field read and write information by each test when executing
in the order of Test1, Test2, Test3, and Test4.
\vspace{1mm}

\begin{tabular}{|c|l|l|l|l|}
%\toprule
\hline
\textbf{Shared Fields } & \textbf{Test1} & \textbf{Test2} & \textbf{Test3}& \textbf{Test4}\\
\hline
\code{x} & Read & & Write& Read\\
\hline
\code{y} & & Read & &Write \\
\hline
\end{tabular}

\vspace{4mm}

Number of permutations that need to be executed.
\setlength{\tabcolsep}{0.5\tabcolsep}
\begin{tabular}{|c|c|c|}
%\toprule
\hline
\textbf{$k$ value} & \textbf{Basic Algorithm} & \textbf{Improved Algorithm}  \\
\hline
1 & 4 & 1\\
\hline
2 & 12 & \\
\hline
3 & 24 & \\
\hline
4 & 24 & \\
\hline
\textbf{Total} & 64 & \\
\hline
\end{tabular}


\Caption{Example tests to illustrate the improved
dependent test detection algorithm (Figure~\ref{fig:impralg}).}
\label{fig:rwexample}
\end{figure}

Although our basic algorithm bounds the
number of possible permutations to $O(n^k)$,
it cannot scale to a realistic test suite.
For example, using $k=3$, the time for
executing all possible test permutation
in JodaTime's test suite (3875 tests, Table~\ref{tab:subjects})
is measured by months.

To reduce the search space, our improved algorithm
uses dynamic analyses to avoid executing test
permutations that are guaranteed to have the
same results as being executed in the default order.
The intuition of our algorithm is that,
given a test permutation, for \textit{each}
test, if \textit{all shared fields} it reads
are written by the \textit{same} test as
in the default execution order, all tests in
the permutation are guaranteed to
have the same results and the permutation can be safely ignored. 

Our algorithm (Figure~\ref{fig:impralg}) takes the same
input as the basic algorithm. It first executes the whole
test suite in its default order
to record test execution results (line 2) as
well as fields that each test reads and writes (line 3).
Then, for every field read by a test,
the algorithm identifies the last test that write
to that field (line 4).
After that, the algorithm generates all possible test permutations
up to length $k$. Before executing each permutation, 
it checks whether all fields a test may read are written
by the same tests as in the default order (lines 6--9).
If so, the algorithm concludes that tests in the permutation
must reveal the same results. Otherwise,
it executes the permutation and records the tests with
different execution results. Lines 10---15 in Figure~\ref{fig:impralg}
are the same to lines 4---9 in Figure~\ref{fig:dtalgorithm}.
%in which every test must
%reveal the same result to reduce the total number
%of permutations which need to be explored.

To illustrate this algorithm, Figure~\ref{fig:rwexample} shows an example
consisting of 2 shared fields and 4 tests. In the default execution
order, Test 1 reads the \textit{initial} value of \code{x};
Test2 reads the \textit{initial} value of \code{y}, and Test4
reads the value of \code{x} written by Test3.
Based on this observation, when creating permutations with $k=1$,
only Test4 needs to be executed, since it will read the
\textit{initial} value of \code{x} rather than the \code{x}
value written by Test3. When creating permutations with $k=2$,
only \todo{how many} need to be executed.
The number of permutations that need to executed when
$k=3$ and $k=4$ is shown in Figure~\ref{fig:rwexample}.

\todo{should mention that this algorithm is quite conservation,
and why it is correct. We ignore write}

\todo{illustrate why simply group tests by read/write is incorrect.}

\todo{give an intuition of why it can improve scalability, since
not every test will overlap with each other.}



%In case a test $t_2$ does not potentially \todo{?} depend on a previously executed test $t_1$, this means 
%that all permutations of tests in which $t_2$ follows $t_1$ do not need to be considered for potential \todo{?} dependency
%given that all tests on which $t_1$ potentially \todo{?} depends on are present as a prefix of that permutation, 
%in the same order that the test suite was initially executed, thus reducing the number of permutations which
%need to be explored.

\todo{I prefer to talk about file systems, optimizations
that use user-provided annotations, the prefix of a permutation,
and use multiple executions to
guide selection in the implementation section.}
