\section{Detecting Dependent Tests}
\label{sec:detecting}

\newcommand{\smalltrialnum}{10\xspace}
\newcommand{\mediumtrialnum}{100\xspace}
\newcommand{\trialnum}{1000\xspace}

\newcommand{\testlist}[0]{\ensuremath{T^k_i}}
\newcommand{\executeTestsInOrder}[1]{\result{#1}{\env_0}}

%An exhaustive search would execute all $n!$
%permutations of the test suite to detect dependent tests.
%However, this is not feasible for realistic $n$.
Since the general form of the dependent test detection problem is
NP-complete, we do not expect to find an efficient algorithm for it.

To approximate the exact solution, this section
presents three approximate algorithms that find a \textit{subset} of
all dependent tests.
%In this section we present two algorithms to detect dependent
%tests. 
Section~\ref{sec:randomized} describes a randomized algorithm
that repeatedly executes all the tests of a suite in random order.
Section~\ref{sec:basic} describes an exhaustive bounded algorithm that
executes all possible sequences of $k$ tests for a bounding parameter $k$
(specified by the user).
Section~\ref{sec:advalgorithm} describes a \dependenceaware{} $k$-bounded algorithm.
The \dependenceaware{} algorithm dynamically collects the
static fields that each test
reads or writes, and uses the collected information to reduce the search space.
All three algorithms are \textit{sound} but \textit{incomplete}:
every dependent test they find is real, but they do not
guarantee to find every dependent test.


\begin{figure}[t]
\textbf{Input}: a test suite $\mathit{T}$\\
\textbf{Output}: a set of dependent tests $\mathit{dependentTests}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\emptyset$
\STATE $\mathit{expectedResults}$ $\leftarrow$ $\result{T}{\env_0}$
\FOR{each $\mathit{ts}$ in getPossibleExecOrder($\mathit{T}$)}
\STATE $\mathit{execResults}$ $\leftarrow$ $\result{\mathit{ts}}{\env_0}$
\FOR{each test $\mathit{t}$ in $\mathit{ts}$}
\IF{$\mathit{execResults}$[$\mathit{t}$] $\neq$ $\mathit{expectedResults}$[$\mathit{t}$]}
\STATE $\mathit{dependentTests}$ $\leftarrow$ $\mathit{dependentTests}$ $\cup$ $\mathit{t}$
\ENDIF
\ENDFOR
\ENDFOR
\RETURN $\mathit{dependentTests}$
%\ENDWHILE
\end{algorithmic}

% getPossibleExecOrder($T$, $k$): returns a set of test suites, each of size
% $\le k$; each suite is composed of tests selected from $T$ without replacement.\\

\vspace{-3mm}
\caption {The algorithm to detect dependent tests.
The getPossibleExecOrder function is instantiated
by different algorithms in Figures~\ref{fig:randalgorithm},
~\ref{fig:exhaustivealgorithm}, and ~\ref{fig:impralg}.
}
\label{fig:basealgorithm}
\end{figure}


\begin{figure}[t]
getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\FOR{$i$ in 1..$\mathit{numtrials}$}
\STATE \textbf{yield} shuffle($T$)
\ENDFOR
\end{algorithmic}

\vspace{-3mm}
\caption {The randomized algorithm to detect dependent tests.
It instantiates the algorithm of Figure~\ref{fig:basealgorithm}, defining
the getPossibleExecOrder function.
Our experiments use $\mathit{numtrials} = \smalltrialnum,
\mediumtrialnum, \trialnum$.}
\label{fig:randalgorithm}
\end{figure}


\subsection{Randomized Algorithm}
\label{sec:randomized}

Figure~\ref{fig:randalgorithm} shows the algorithm.
Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, this algorithm
first executes $T$ with its default order
to obtain the \emph{expected result} of each test (line 2).
Then, it randomizes the original
test execution order (line 3), and then executes each test
again to observe its result (line 4). The algorithm checks
whether the result of any test differs from the
expected result (lines 5--9). 

%In our implementation, this algorithm repeatedly
%shuffles the test suite, and executes each test 
%for a pre-defined number of iterations.
%Our experiments use $\smalltrialnum,
%\mediumtrialnum, \trialnum$ as the iteration numbers.

%until
%no more dependent tests are identified within a
%pre-defined number of iterations. % (default: \smalltrialnum iterations).
%Our experiments use $\smalltrialnum,
%\mediumtrialnum, \trialnum$ as the iteration numbers.

%\todo{How did we choose 10 iterations?  It might be good to try with some
%  different number such as 20 and report that there was no difference.
%  More generally, when choosing an arbitrary number, it adds credibility to
%  either give a justification for the number or to do an experiment to show
%  that the number is a reasonable choice.}


\subsection{Exhaustive Bounded Algorithm}
\label{sec:basic}

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
kPermutations($T$, $k$): returns all $k$-permutations of $T$; that is, all
sequences of $k$ elements of $T$ without repetition

\medskip

getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\RETURN kPermutations($T$, $k$)
\end{algorithmic}

\vspace{-3mm}
\caption {The exhaustive $k$-bounded algorithm to detect dependent tests.
It instantiates the algorithm of Figure~\ref{fig:basealgorithm}, defining the
getPossibleExecOrder function.
%Our experiments use $k=1$ and $k=2$ to bound the length of
%test execution. 
} 
\label{fig:exhaustivealgorithm}
\end{figure}


%To detect all possible dependent tests, 

This algorithm uses the findings of our study
(Section~\ref{sec:study})
that most dependent tests can be found by running only short
subsequences of test suites. For example,
in our study, \pertange of the real-world dependent tests
can be found by running no more than 2 tests together.
Instead of executing all permutations of the
whole test suite, our algorithm (Figure~\ref{fig:exhaustivealgorithm})
executes all $k$-permutations for a bounding
parameter $k$.
By doing so, the algorithm reduces
the number of permutations to execute
to $O(n^k)$, which for small $k$ and $n$ is tractable. 


Figure~\ref{fig:exhaustivealgorithm} shows the algorithm.
Given a test suite $T = \suite{t_1, t_2, \ldots, t_n}$, the
algorithm executes every $k$-permutations of tests,
and checks whether the result of any test differs
from the expected result. Finally, the algorithm returns the set
of all tests $t_i \in T$
that exhibit different results.





\subsection{Dependence-Aware Bounded Algorithm}
\label{sec:advalgorithm}

%\begin{figure}
%\centering
%
%\strut \hspace{-25mm} Initially: \code{x = y = 1;}
%
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test1 \\  if(x == 0) \{ y = 0;\}\\ }
%\end{minipage}
%}
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test2\\ assert y == 1;}
%\vspace{0.9em}
%\end{minipage}
%}
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test3\\ x = 0;}
%
%\vspace{0.5em}
%\end{minipage}
%}
%\subfigure{
%\begin{minipage}{.43\columnwidth}
%\code{Test4 \\  if(x == 0) \{ y = 1;\}\\ }
%\end{minipage}
%}
%
%\strut \hspace{-3mm} Field read and write information by each test when executing
%in the order of Test1, Test2, Test3, and Test4.
%\vspace{1mm}
%
%\begin{tabular}{|c|l|l|l|l|}
%\toprule
%\hline
%\textbf{Global Fields } & \textbf{Test1} & \textbf{Test2} & \textbf{Test3}& \textbf{Test4}\\
%\hline
%\code{x} & Read & & Write& Read\\
%\hline
%\code{y} & & Read & &Write \\
%\hline
%\end{tabular}
%
%\vspace{4mm}
%
%Number of permutations that need to be executed.
%\setlength{\tabcolsep}{1.3\tabcolsep}
%\begin{tabular}{|c|c|c|}
%\toprule
%\hline
%\textbf{$k$ value} & \textbf{Exhaustive } &
%\textbf{Dependence-Aware }  \\
%\hline
%1 & 4 & 1\\
%\hline
%2 & 12 & 5\\
%\hline
%3 & 24 & 18 \\
%\hline
%4 & 24 & 20 \\
%\hline
%\hline
%\textbf{Total} & 64 & 44 \\
%\hline
%\end{tabular}
%
%
%\Caption{Example tests to illustrate the \dependenceaware{}
%$k$-bounded dependent test detection algorithm (Figure~\ref{fig:impralg}).}
%\label{fig:rwexample}
%\end{figure}

%The exhaustive $k$-bounded algorithm cannot scale to a realistic test suite.
%For example, it would take months to 
%execute all 3-permutations
%in Joda-Time's test suite (3875 tests, Table~\ref{tab:subjects}).

\todo{please check the whole section here. is it clear?}

The \dependenceaware{} $k$-bounded algorithm
detects the same number of dependent tests
as the exhaustive $k$-bounded algorithm does (when using the same $k$),
but it uses dynamic analyses to prune the search space.
%Information obtained from shorter permutations is used to avoid running lonnger permutations; 

When $k$=1, the algorithm executes all tests in the default order
within the same JVM, and discards tests that do \textit{not}
access (including read and write) any global fields or
other external resources such as a file. Then,
the algorithm executes each of the remaining tests in isolation (i.e., in a fresh JVM),
and reports the tests whose results are different as executed in
the default order.

Figure~\ref{fig:impralg} shows the algorithm for $k$$\ge$2.
%
The intuition of this algorithm is that, given
a test permutation, for \textit{each} test,
if \textit{every global field} (and other 
resources from the execution environment) it reads
is \textit{not} written by any test executed \textit{before} it,
all tests in the permutation are guaranteed to produce
the same results as executed in isolation (since each
test does not interfere with any other tests). Thus, the permutation
can be safely ignored. \todo{Darioush, check the above,
how could this permutation be safely ignored, if the result
is only the same as in isolation (not the default order?)}
The algorithm redefines
the getPossibleExecOrder function in Figure~\ref{fig:basealgorithm}.
The redefined getPossibleExecOrder function first executes
each test in \textit{isolation}, and records the
fields that each test reads and writes (lines 1--3).
\todo{need to explain why executed in isolation?}
When generating all possible test permutations
of length $k$, the algorithm checks whether
\textit{all} global fields \textit{each} test (in the generated permutation)
may read are not written by \textit{any} test executed before it (lines 6--10).
If so, all tests in the permutation
must produce the same results as executed in isolation,
and the algorithm can safely discard this permutation without
executing it. Otherwise, the algorithm adds the generated
permutation to the result set (line 9), and runs the algorithm in Figure~\ref{fig:basealgorithm}
to identify dependent tests. %among it.
Due to space limits, we omit the proof of the correctness
of the \dependenceaware{} $k$-bounded algorithm. Interested
readers can refer to~\cite{proof-dependence-aware} for proof.

The \dependenceaware{} $k$-bounded algorithm has two major benefits.
First, it clusters tests by the fields they
read and write. Only tests reading or writing
the same global field(s), rather than \textit{all} tests
in a suite, are treated as potentially dependent.
Second, for tests reading or writing the same global
field(s), some permutations can be ignored by checking
the global fields each test may access. 

\begin{figure}[t]
\textbf{Auxiliary methods}:\\
recordFieldAccess($\mathit{t}$): executes a test $\mathit{t}$ in
a fresh JVM and returns the fields it reads and writes.\\
%by a test $t$. \\% in an ordered sequence of tests $\mathit{ts}$. \\


\vspace{-2mm}

getPossibleExecOrder($T$):\\
\vspace{-5mm}
\begin{algorithmic}[1]
\FOR { each $\mathit{t}$ in $\mathit{T}$ }
\STATE $\langle \mathit{reads}_t, \mathit{writes}_t\rangle$ $\leftarrow$ recordFieldAccess($\mathit{t}$)\\ 
\ENDFOR

\STATE $\mathit{result}$ $\leftarrow$ $\emptyset$ \\
\FOR{each $\mathit{ts}$ in kPermutations($\mathit{T}$, $\mathit{k}$)}
	\FOR {each $\mathit{t_i}$ in $\mathit{ts}$ \{ $\mathit{i}$ is the index of $\mathit{t_i}$ in $\mathit{ts}$ \}} 
		\STATE $\mathit{previousWrites}$ $\leftarrow$ $\bigcup_{\mathit{j} < \mathit{i}}  \mathit{writes}_{t_j} $ \\
		\IF {$\mathit{previousWrites} \cap \mathit{reads}_{t_i} \neq \emptyset$}
			\STATE $\mathit{result} \leftarrow \mathit{results} \cup \mathit{ts}$
		\ENDIF
	\ENDFOR

\ENDFOR
\RETURN $\mathit{result}$
\end{algorithmic}

\vspace{-3mm}
\caption {The \dependenceaware{} $k$-bounded algorithm to detect dependent tests.
It instantiates the algorithm of Figure~\ref{fig:basealgorithm}, defining the
getPossibleExecOrder function.
%Our experiments uses $k=1$, \todo{experiment setting, how
%large k it can scale to.}. 
} 
\label{fig:impralg}
\end{figure}


%in which every test must
%reveal the same result to reduce the total number
%of permutations which need to be explored.

%To better illustrate the second benefit, Figure~\ref{fig:rwexample}
%shows an example
%consisting of 2 global fields and 4 tests. In the default execution
%order, Test 1 reads the \textit{initial} value of \code{x};
%Test2 reads the \textit{initial} value of \code{y}, and Test4
%reads the value of \code{x} written by Test3.
%Based on such recorded information, when creating permutations with $k=1$,
%our algorithm determines that only
%Test4 needs to be executed, since Test4, if executed in isolation,
%will read the \textit{initial} value of \code{x} rather than the \code{x}
%value written by Test3. Similarly, when creating permutations with $k=2$,
%only 5 out of 12 permutations ($\langle$Test1, Test4$\rangle$,
%$\langle$Test2, Test4$\rangle$, $\langle$Test4, Test1$\rangle$,
%$\langle$Test4, Test2$\rangle$, and $\langle$Test4, Test3$\rangle$) need to be executed.
%Due to space limits, we omit test permutations when
%$k=3$ and $k=4$, and list the number of permutations that need
%to execute in Figure~\ref{fig:rwexample}.

%\todo{illustrate why simply group tests by read/write is incorrect.}


%\todo{give an intuition of why it can improve scalability, since
%not every test will overlap with each other.}



%In case a test $t_2$ does not potentially \todo{?} depend on a previously executed test $t_1$, this means 
%that all permutations of tests in which $t_2$ follows $t_1$ do not need to be considered for potential \todo{?} dependency
%given that all tests on which $t_1$ potentially \todo{?} depends on are present as a prefix of that permutation, 
%in the same order that the test suite was initially executed, thus reducing the number of permutations which
%need to be explored.


%\begin{comment}



%  LocalWords:  getPossibleExecOrder numtrials lastWriteTS previousWrites
%  LocalWords:  lastWrites
